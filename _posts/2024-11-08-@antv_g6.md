---
layout: post
title: G6
categories: [G6]
tags: [G6, 数据可视化]
---

``G6`` 简介：强分析、高性能、易扩展的图可视分析引擎。[蚂蚁数据可视化官网](https://antv-2018.alipay.com/zh-cn/index.html)、[G6官网](https://g6.antv.antgroup.com/)、[关于G6](https://antv-2018.alipay.com/zh-cn/g6/3.x/index.html)、[版本5示例](https://g6.antv.antgroup.com/examples)、[版本4示例](https://g6-v4.antv.vision/examples#net-dagreFlow)、[版本4简介](https://g6-v4.antv.vision/manual/introduction)、[版本4 api](https://g6-v4.antv.vision/api/Graph)


**<font color=red>注：本教程的所有 demo 都是基于 @antv/g6 的 4.8.24 版本。</font>**


# G6
+ [基础](#基础)
  + [点和边的配置](#点和边的配置)
  + [箭头的配置](#箭头的配置)
  + [Combo 节点分组](#combo-节点分组)
  + [聚类轮廓包裹](#聚类轮廓包裹)
  + [布局的配置](#布局的配置)
    + [默认布局](#默认布局)
    + [随机布局](#随机布局)
    + [层次布局(流程图)](#层次布局流程图)
  + [状态](#状态)
    + [配置时机](#配置时机)
    + [调用时机](#调用时机)
    + [重写 & 取消](#重写--取消)
    + [状态注意事项](#状态注意事项)
  + [事件](#事件)
    + [基础事件](#基础事件)
    + [时机事件](#时机事件)
+ [进阶](#进阶)
  + [自定义节点](#自定义节点)
  + [自定义边](#自定义边)
  + [交互行为](#交互行为)
  + [图形分组](#图形分组)
  + [Tooltip](#tooltip)
+ [api](#api)



## 基础
### 点和边的配置
![g6_03](/static/img/g6/g6_03.jpg)

```vue
{% raw %}
<template>
  <div ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 120, // 节点的大小
          type: 'path', // 内置（circle/ellipse/image/rect/path/marker/polygon）/自定义节点类型（默认为 circle）
          label: '起始点', // 文本文字
          anchorPoints: [ // 连接点数组
            [0.5, 0]
          ],
          labelCfg: { // 文本样式
            // 'center'，'top'，'left'，'right'，'bottom'，内置 ModelRect（方卡片）类型不支持该属性
            position: 'center',
            // 文本的偏移，position 为 'bottom' 时，文本的上方偏移量；position 为 'left' 时，文本的右方偏移量；以此类推在其他 position 时的情况。modelRect 节点的 offset 为左边距
            // offset: 0,
            style: {
              // 通用属性
              name: 'n1',
              fill: '#fff',
              stroke: 'black',
              lineWidth: 4, // 描边大小
              // lineDash: [2, 2], // 虚线：第1项线条长度、第2项间隔长度
              shadowColor: 'orange',
              shadowBlur: 2,
              shadowOffsetX: 0,
              shadowOffsetY: 0,
              opacity: 1,
              fillOpacity: 1,
              strokeOpacity: 1,
              cursor: 'pointer',

              // 文本特有属性
              // text: '优先级高于节点的 label 属性', // 会替换 label 的文本内容
              textAlign: 'center', // center / end / left / right / start
              textBaseline: 'bottom', // top / middle / bottom
              fontStyle: 'italic', // italic / normal
              // fontVariant: 'normal', // css 样式（不常用）
              fontWeight: 'bold',
              fontSize: 30,
              fontFamily: 'Microsoft YaHei',
              lineHeight: 30, // 单行文本体现不出来
              // 需要设置 renderer 为 'svg' 方可配置 html，使用 Html 事件只能用 dom 事件
              // html: '<div></div>'
            }
          },
          style: {
              // 通用属性
              name: 'n1',
              fill: 'orangered',
              stroke: 'violet',
              lineWidth: 10, // 描边大小
              lineDash: [2, 2], // 虚线：第1项线条长度、第2项间隔长度
              shadowColor: 'black',
              shadowBlur: 2,
              shadowOffsetX: 1,
              shadowOffsetY: 1,
              opacity: 1,
              fillOpacity: 1,
              strokeOpacity: 1,
              cursor: 'pointer',

              // 圆形特有属性
              // x: 100, // 圆心 x 位置
              // y: 100, // 圆心 y 位置
              // r: 90, // 圆半径（优先级高于 size 配置）

              // 椭圆形特有属性
              // x: 100,
              // y: 80,
              // rx: 100, // 水平半径
              // ry: 140 // 垂直半径

              // 图片特有属性
              // x: 0, // 图片左上角 x 位置
              // y: 0, // 图片左上角 y 位置
              // width: 80,
              // height: 80,
              // img: '/image/logo.png', // 图片 url

              // 标记图形 Marker 特有属性
              // x: 20,
              // y: 20,
              // r: 50,
              // // 内置形状 circle/square/diamond/triangle/triangle-down，也可以是函数返回路径
              // symbol: 'triangle',

              // 多边形特有属性
              // points: [
              //   [30, 30],
              //   [40, 20],
              //   [30, 50],
              //   [60, 100]
              // ]
              
              // 矩形特有属性
              // x: 0,
              // y: 0,
              // width: 100,
              // height: 80,
              // radius: 20

              // 路径特有属性
              path: [
                ['M', 100, 100],
                ['L', 200, 200]
              ],
              startArrow: true, // 也可以是自定义箭头
              endArrow: true,
              lineAppendWidth: 10, // 边的击中范围，增加点击范围
              lineCap: 'miter', // 设置线条的结束端点样式 bevel(斜角)round(圆角)miter(尖角 (默认))
              lineJoin: 'miter', // 设置两条线相交时，所创建的拐角形状（枚举值同上）
              lineWidth: 10, // 线条宽度
              // miterLimit: 5, // 设置最大斜接长度
              // lineDash: [2, 2] // 虚线
          }
        },
        {
          id: 'node2',
          x: 500,
          y: 200,
          size: 120,
          label: '目标点',
          labelCfg: {
            style: {
              fontSize: 24
            }
          }
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线',
          type: 'loop', // line/polyline/quadratic/cubic/arc/loop 以是内置边的类型名称，也可以是自定义边的名称
          // sourceAnchor: 0, // 起点的连接点的索引
          // targetAnchor: 0, // 终点点的连接点的索引
          // color: 'orange', // 优先级低于 style.stroke
          style: {
            // 通用属性
            name: 'l1-2',
            stroke: 'violet',
            lineWidth: 10, // 描边大小
            lineDash: [8, 2], // 虚线：第1项线条长度、第2项间隔长度
            shadowColor: 'black',
            shadowBlur: 2,
            shadowOffsetX: 1,
            shadowOffsetY: 1,
            // opacity: 0.1,
            // strokeOpacity: 1, // 优先级高于 opacity
            cursor: 'pointer'
          },
          labelCfg: {
            refX: 20,
            refY: 20,
            position: 'middle', // start/middle/end
            autoRotate: true,
            style: {
              fontSize: 18
            }
          },
          // stateStyles: {} // 略

          // 内置边 polyline 特有属性
          // routeCfg: {
          //   gridSize: 10, // 指定精度
          //   maxAllowedDirectionChange: Math.PI / 2, // 允许的最大转角，弧度制
          //   // obstacles: [graph.findById('node1'), graph.findById('node2')], // 需要躲避的障碍节点对象
          // },
          // style: {
          //   offset: 20,  // 拐弯处距离节点最小距离
          //   radius: 10,  // 拐弯处的圆角弧度，若不设置则为直角
          // },
          // 控制点数组 - 不指定时根据 A* 算法自动生成折线。若指定了，则按照 controlPoints 指定的位置进行弯折。示例：[{ x: 10, y: 20 }, { x: 20, y: 25 }, ...]
          // controlPoints: [{ x: 10, y: 20}],

          // 内置边 quadratic 特有属性
          // controlPoints: [{ x: 40, y: 40 }], // 控制点（photoshop 中的钢笔工具的路径点）
          // curvePosition: 0.1, // 优先级低于 controlPoints，控制点的位置比例
          // 控制点距离两端点连线的距离，可理解为控制边的弯曲程度，cubic、horizontal、cubic-vertical、cubic-horizontal 等贝塞尔曲线特有
          // curveOffset: -50,



          // 内置边 cubic 特有属性
          // controlPoints: [{ x: 500, y: 400 }, { x: 300, y: 0 }], // 不指定时将会使用默认的控制点：曲线 1/3 和 2/3 处，二阶贝塞尔曲线 需要 2 个控制点
          // curvePosition: [0.4, 0.9], // 优先级低于 controlPoints，控制点的位置比例
          // curveOffset: [-90, 90], // 优先级低于 controlPoints，和 curvePosition 组合使用
          // minCurveOffset: [-30, 30], // 优化 curveOffset ,设置了一个最小值



          // 内置类型 arc 圆弧特有属性
          // curveOffset: 40, // 圆弧顶端距离两线中心位置的距离


          // 内置 loop 边特有属性（loop 边适用于自环边，即起始点与结束点为相同节点的边，在不同端点的边上适用 loop 边将会出现异常效果。）
          // style: {
          //   endArrow: true,
          // },
          // loopCfg: {
          //   position: 'top', // top, top-right, right,bottom-right, bottom, bottom-left, left, top-left
          //   dist: 100, // 从节点 keyShape 的边缘到自环最顶端的位置，用于指定自环的曲度，默认为节点的高度。
          //   clockwise: true, // 指定是否顺时针画环，默认为  true。
          //   pointPadding: 15, // 对于非圆形节点设置的连接点与节点中心坐标，在 x 轴或 y 轴方向的偏移量，默认为  节点宽高中最小值的1/4，也可以是数组4个值
          // }
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: 600,
      height: 600,
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
``` 




### 箭头的配置
![g6_04](/static/img/g6/g6_04.jpg)

```vue
{% raw %}
<template>
  <div ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 120, // 节点的大小
          type: 'circle',
          label: '起始点',
          labelCfg: {
            style: {
              name: 'n1',
              fill: '#fff',
              stroke: 'black',
              fontSize: 30,
            }
          },
          style: {
              name: 'n1',
              fill: 'orangered',
              stroke: 'violet'
          }
        },
        {
          id: 'node2',
          x: 500,
          y: 200,
          size: 60,
          size: 120,
          label: '目标点',
          labelCfg: {
            style: {
              fontSize: 24
            }
          }
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线',
          style: {
            // 通用属性
            name: 'l1-2',
            stroke: 'violet',
            lineWidth: 10,
            endArrow: true,
            startArrow: {
              // 类型：triangle/vee/circle/diamond/rect/triangleRect  
              path: G6.Arrow.triangle(40, 40, 10), // 参数依次为 宽、长、偏移量
              d: 20, // 箭头的偏移量（一般情况下与 G6.Arrow 的方法的偏移量保持一致即可）
              fill: 'red',
              stroke: 'blue',
              lineWidth: 2, // 描边宽度
              lineDash: [2, 2], // 描边的虚线
              opacity: 1,
              shadowColor: 'red',
              shadowColorBlur: 2,
              shadowOffsetX: 1,
              shadowOffsetY: 1
            }
          },
          labelCfg: {
            refX: 20,
            refY: 20,
            autoRotate: true,
            style: {
              fontSize: 18
            }
          }
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: 600,
      height: 600,
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```
> 每个类型的具体参数[文档](https://g6-v4.antv.vision/manual/middle/elements/edges/arrow)。






### Combo 节点分组
Combo 节点分组是非常实用的一个功能，通过定义不同的 Combo 将点拖动到不同标注区域的 Combo 内进行分组归类分析。

![g6_05](/static/img/g6/g6_05.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 60, // 节点的大小
          type: 'circle',
          label: '起始点',
          labelCfg: {
            style: {
              name: 'n1',
              fill: '#fff',
              stroke: 'black',
              fontSize: 16,
            }
          },
          style: {
              name: 'n1',
              fill: 'orangered',
              stroke: 'violet'
          }
        },
        {
          id: 'node2',
          x: 500,
          y: 200,
          size: 80,
          label: '目标点',
          labelCfg: {
            style: {
              fontSize: 18
            }
          }
        }
      ],
      combos: [ // combo 集合
        {
          id: 'combo1',
          type: 'circle', // circle/rect
          label: '节点分组1',
          labelCfg: {
            position: 'center',
            refX: 10,
            refY: 10,
            style: {
              fill: 'blue',
              fontSize: 16
            }
          },
          // parentId: 'combo0' // 当前 combo 的父 combo
          size: 100, // 最小尺寸，原型就是圆心，矩形设置宽高为数组
          padding: 40,
          // fixSize: 300, // 固定尺寸，不固定时有内部元素决定，若指定了 fixSize 而没有指定 fixCollapseSize，则即使该 Combo 在收起状态下仍然保持 fixSize 指定的尺寸
          fixCollapseSize: 100, // 固定 combo 收起时的尺寸，未指定 fixSize 时由 size 决定，否则就是 fixSize
          collapsed: false, // 折叠状态
          collapsedSubstituteIcon: { // 折叠状态展示的图片
            show: true,
            img: '/image/logo.png',
            width: 50,
            height: 50
          },
          style: {
            fill: 'gainsboro'
          },
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线',
          style: {
            // 通用属性
            name: 'l1-2',
            stroke: 'violet',
            lineWidth: 4
          },
          labelCfg: {
            refX: 20,
            refY: 20,
            autoRotate: true,
            style: {
              fontSize: 18
            }
          }
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理
      groupByTypes: false,
      modes: {
        default: [
          'drag-combo', // 允许拖动 combo
          'drag-node', // 允许拖动 节点
          'collapse-expand-combo', // 双击 折叠/展开 combo
        ]
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```
> + 节点分组 [demo](https://g6-v4.antv.vision/zh/examples/net/comboLayout#comboCombined)
+ **<font color=red>若图配置有布局且该 behavior 的 relayout 配置项为 true（默认为 true），则该 behavior 被触发后会触发图的重新布局。若希望避免重新布局，可以配置 relayout 为 false ，或通过监听 combo 点击事件和 graph.collapseExpandCombo API 控制收缩展开逻辑。</font>**




### 聚类轮廓包裹
![g6_02](/static/img/g6/g6_02.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%; height: 100%" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo4",
  mounted() {
    const data = {
      nodes: [
        // 点集合
        {
          id: "node1",
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 60, // 节点的大小
          type: "circle",
          label: "起始点",
          labelCfg: {
            style: {
              fill: "#fff",
              stroke: "black",
              fontSize: 16,
            },
          },
          style: {
            fill: "orangered",
            stroke: "violet",
          },
        },
        {
          id: "node2",
          x: 300, // 坐标点
          y: 200, // 坐标点
          size: 60, // 节点的大小
          type: "circle",
          label: "中间点",
          labelCfg: {
            style: {
              fill: "#fff",
              stroke: "black",
              fontSize: 16,
            },
          },
          style: {
            fill: "orangered",
            stroke: "violet",
          },
        },
        {
          id: "node3",
          x: 500, // 坐标点
          y: 200, // 坐标点
          size: 60, // 节点的大小
          type: "circle",
          label: "结束点",
          labelCfg: {
            style: {
              fill: "#fff",
              stroke: "black",
              fontSize: 16,
            },
          },
          style: {
            fill: "orangered",
            stroke: "violet",
          },
        },
      ],
      edges: [
        // 边集合
        {
          id: "1-2",
          source: "node1",
          target: "node2",
          label: "我是连线",
          style: {
            stroke: "violet",
            lineWidth: 4,
          },
          labelCfg: {
            refY: 20,
            autoRotate: true,
            style: {
              fontSize: 18,
            },
          },
        },
        {
          id: "2-3",
          source: "node2",
          target: "node3",
          label: "我是连线",
          style: {
            stroke: "violet",
            lineWidth: 4,
          },
          labelCfg: {
            refY: 20,
            autoRotate: true,
            style: {
              fontSize: 18,
            },
          },
        },
      ],
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
    });

    let h1;

    graph.on('afterrender', () => {
      h1 = graph.createHull({
        id: 'h-1',
        /**
         * 类型：round-convex 圆角凸包轮廓 / smooth-convex 平滑凸包轮廓 / bubble 平滑凹包轮廓
         * */
        type: 'round-convex',
        members: ['node1', 'node2'],
        // nonMembers: ['node2'], // 仅针对 bubble 类型有效（目前不清楚何种场景生效）
        padding: 10,
        style: {
          fill: 'lightgreen',
          stroke: 'green',
        }
      });
    });

    // 手动更新聚类的节点结合
    setTimeout(() => {
      console.log(graph.getHulls()); // 获取所有轮廓 map
      h1.updateData(['node2', 'node3']);
    }, 3000);

    setTimeout(() => {
      graph.removeHull('h-1'); // 移除指定的 id 的轮廓
      // graph.removeHulls();
    }, 5000);

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```


### 布局的配置
#### 默认布局
![g6_07](/static/img/g6/g6_07.jpg)
实例化不配置 ``layout`` 时采用默认布局，数据中存在  ``x`` 和 ``y`` 属性时，就按照数据位置信息绘制，如果没有就按照 ``Random Layout`` 进行布局。

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 300,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        type: 'circle',
        size: 80,
        labelCfg: {
          style: {
            fill: '#fff',
            stroke: 'black',
            fontSize: 16,
          }
        },
        style: {
            fill: 'orangered',
            stroke: 'violet'
        }
      },
      defaultEdge: {
        style: {
          stroke: 'violet',
          lineWidth: 4
        },
        labelCfg: {
          refX: 20,
          refY: 20,
          autoRotate: true,
          style: {
            fontSize: 18
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```




#### 随机布局
![g6_06](/static/img/g6/g6_06.jpg)
节点没有 ``x`` 和 ``y`` 配置，随机布局的算法决定节点位置。

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          label: '起始点'
        },
        {
          id: 'node2',
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      fitCenter: true,
      layout: { // 布局配置对象
        type: 'random', // 随机布局
        center: [0, 0],
        width: 800, // 布局宽
        height: 600, // 布局高
        workerEnabled: true // 是否启用 web-worker 以防布局计算时间过长阻塞页面交互
      },
      defaultNode: {
        type: 'circle',
        size: 80,
        labelCfg: {
          style: {
            fill: '#fff',
            stroke: 'black',
            fontSize: 16,
          }
        },
        style: {
            fill: 'orangered',
            stroke: 'violet'
        }
      },
      defaultEdge: {
        style: {
          stroke: 'violet',
          lineWidth: 4
        },
        labelCfg: {
          refX: 20,
          refY: 20,
          autoRotate: true,
          style: {
            fontSize: 18
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```

#### 层次布局(流程图)
自由度高，节点之间配置连线即可， ``G6.TreeGraph`` 树图由于数据结构是树形的没法反向连线（[流程图配置项](https://g6-v4.antv.vision/api/graph-layout/dagre)）。

**<font color=red>注：建议看完</font>** [自定义节点](#自定义节点) **<font color=red>和</font>** [自定义边](#自定义边) **<font color=red>后再看此布局，此 demo 使用了自定义边和自定义节点。</font>**

![g6_01](/static/img/g6/g6_01.jpg)

``data.js``
```javascript
export default {
  nodes: [
    { id: '1', title: '1', description: '1-xxx' },
    { id: '2', title: '2', description: '2-xxx' }, { id: '3', title: '3', description: '3-xxx' },
    { id: '4', title: '4', description: '4-xxx' },
    { id: '5', title: '5', description: '5-xxx' },
    
  ],
  edges: [
    { source: '1', target: '2', label: '1-2' },
    { source: '1', target: '3', label: '1-3' },
    { source: '2', target: '4', label: '2-4' },
    { source: '3', target: '4', label: '3-4' },
    { source: '4', target: '5', label: '4-5' },
  ]
};
```

``dagre.vue``
```vue
{% raw %}
<template>
  <div ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";
import dagreData from "./data.js";

export default {
  name: "demo",
  created() {
    // 自定义节点
    G6.registerNode("card-node", {
      draw: function drawShape(cfg, group) {
        const r = 2;
        const color = "#5B8FF9";
        // cfg 为 defaultNode 配置项配的引用 & 节点数据项的引用
        const w = cfg.size[0];
        const h = cfg.size[1];
        // addShap 方法的结果要作为方法的返回值使用
        const shape = group.addShape("rect", {
          name: "整体背景色块",
          attrs: {
            x: -w / 2,
            y: -h / 2,
            width: w,
            height: h,
            stroke: color,
            radius: r,
            fill: "#fff"
          }
        });
        group.addShape("rect", {
          name: "标题背景色块",
          attrs: {
            x: -w / 2,
            y: -h / 2,
            width: w,
            height: h / 2,
            fill: color,
            radius: [r, r, 0, 0]
          }
        });
        group.addShape("text", {
          name: "标题文本",
          attrs: {
            textBaseline: "top",
            x: -w / 2 + 8,
            y: -h / 2 + 2,
            lineHeight: 20,
            text: cfg.title,
            fill: "#fff"
          }
        });
        group.addShape("text", {
          name: "描述文本",
          attrs: {
            textBaseline: "top",
            x: -w / 2 + 8,
            y: -h / 2 + 24,
            lineHeight: 20,
            text: cfg.description,
            fill: "rgba(0,0,0, 1)",
          }
        });

        return shape;
      }
    });

    // 自定义边
    G6.registerEdge("card-edge", {
      labelAutoRotate: true,
      draw(cfg, group) {
        const startPoint = cfg.startPoint;
        const endPoint = cfg.endPoint;
        // cfg 为 defaultEdge 配置项配的引用 & 边线数据项的引用
        const stroke = (cfg.style && cfg.style.stroke) || this.options.style.stroke;
        const shape = group.addShape("path", {
          name: "边线",
          attrs: {
            stroke,
            path: [
              ["M", startPoint.x, startPoint.y],
              ["L", endPoint.x, endPoint.y],
            ],
          }
        });
        
        // 边线文字
        group.addShape("text", {
          name: "边线文字",
          attrs: {
            text: cfg.label,
            fill: "#595959",
            textAlign: "center",
            textBaseline: "middle",
            x: startPoint.x + (endPoint.x - startPoint.x) / 2,
            y: startPoint.y + (endPoint.y - startPoint.y) / 2
          }
        });

        return shape;
      },
    });
  },
  mounted() {
    const dagre = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: 1840,
      height: 600,
      modes: {
        default: [
          "drag-canvas", // 拖动画布
          "zoom-canvas", // 缩放画布
        ],
      },
      layout: {
        type: "dagre", // 流程图
        // begin: [0, 0], // 布局的左上角对齐位置
        rankdir: "TB", // 布局顺序 'TB' | 'BT' | 'LR' | 'RL'
        align: undefined, // 对齐方式 'UL' | 'UR' | 'DL' | 'DR' | undefined（默认为 undefined，对称布局）
        nodesep: 50, // 节点的水平或垂直（根据布局顺序而定）间距
        // nodesepFunc: function (n) {}, // nodesep 的回调函数
        ranksep: 10, // 层间距
        // ranksepFunc: function (n) {}, // ranksep 的回调函数
        controlPoints: false, // 是否保留布局连线的控制点
        workerEnabled: false, //  是否启用 web-worker 以防布局计算时间过长阻塞页面交互。 ⚠️ 注意: workerEnabled: true 时，不支持所有函数类型的参数。
        sortByCombo: false, // 同一层节点是否根据每个节点数据中的 comboId 进行排序，以防止 combo 重叠
        nodeOrder: undefined, // 同层节点顺序的参考数组，存放节点 id 值。若未指定，则将按照 dagre 本身机制排列同层节点顺序。
      },
      defaultNode: {
        type: "card-node", // 自定义节点类型（通过 G6.registerNode('card-node', {...})）进行注册（默认节点无需声明此属性）
        size: [80, 50], // 节点大小
        style: {
          stroke: '#c2c8d5'
        },
        anchorPoints: [
          // 节点的连线位置（可以设置多个，0、0.5、1 百分比浮点数，分别表示左、中、右，数组第一个之水平位置第二个之垂直位置）
          [0.5, 0], // 上边界中心点
          [0.5, 1], // 下边界中心点
        ],
      },
      defaultEdge: {
        type: "card-edge", // 自定义边类型（通过 G6.registerEdge('card-edge', {...})）进行注册（默认节点无需声明此属性）
        // lineDash: [2, 2], // 虚线的间距和长度
        style: {
          // 线的样式
          stroke: 'orange'
        },
        labelCfg: {
          // 文字的样式
        },
      },
    });

    dagre.data(dagreData);
    dagre.render();

    // 节点定制化 - 根据条件设置节点的边距或者使用不同的自定义节点类型
    // dagre.node((node) => {
    //   return {};
    // });

    // 边定制化 - 根据条件设置边线的样式或者使用不同的自定义边线类型
    // darge.edge((edge) => {
    //   return {};
    // });

    // 事件绑定 - 画布渲染后触发
    // darge.on("afterrender", () => {
    //   darge.changeSize(500, 500) // 再次改变画布大小
    // });

    // 事件绑定 - 节点点击事件
    // darge.on("node-click", () => {});

    // 事件绑定 - 边点击事件
    // darge.on("edge-click", () => {});

    // api
    // fitView - 图形适应画布大小
    // moveTo - 移动图形到指定坐标
    // changeSize - 改变画布大小
    // getCanvasBBox - 获取图形大小
    // data - 设置数据
    // render - 渲染

    // 技巧
    // 隐藏节点 - 给节点配置 display: false 属性。
    // 隐藏边 - 通过边的定制化设置透明度。
  },
};
</script>

<style lang="less" scoped>
#container {
  height: 100%;
  width: 100%;
}
</style>
{% endraw %}
```
> 流程图 - 自由度高，节点之间配置连线即可，G6.TreeGraph 树图由于数据结构是树形的没法反向连线。


## 状态
![g6_08](/static/img/g6/g6_08.gif)




### 配置时机

**1\. 实例化配置对象配置  ``nodeStateStyles`` 和 ``edgeStateStyles`` 配置。**
```javascript
{% raw %}
const graph = new G6.Graph({
  // 略...
  nodeStateStyles: {
    hover: { // 状态名称
      fill: 'orange'
    }
  },
  edgeStateStyles: {
    hover: { // 状态名称
      fill: 'orange'
    }
  }
  // 略...
});
{% endraw %}
```

**2\. 节点/边数据中定义 ``state`` 样式。**
```javascript
{% raw %}
const data = {
  nodes: [ // 点集合
    {
      id: 'node1',
      x: 100, // 坐标点
      y: 200, // 坐标点
      label: '起始点',
      stateStyles: {
        hover: {
          fill: 'orange'
        }  
      }
    },
    {
      id: 'node2',
      x: 300,
      y: 200,
      label: '结束点',
      stateStyles: {
        hover: {
          fill: 'orange'
        }  
      }
    }
  ],
  edges: [ // 边集合
    {
      id: '1-2',
      source: 'node1',
      target: 'node2',
      label: '我是连线',
      stateStyles: {
        hover: {
          fill: 'orange'
        }  
      }
    }
  ]
};
{% endraw %}
```

**3\. 自定义节点和边时定义 ``state`` 样式。**

见[自定义节点](#自定义节点)、[自定义边](#自定义边)内容。



### 调用时机

**1\. graph.on 的回调函数。**
```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 300,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        type: 'circle',
        size: 80,
        labelCfg: {
          style: {
            fill: '#fff',
            fontSize: 16,
          }
        },
        style: {
          fill: 'orangered',
          stroke: 'violet'
        }
      },
      defaultEdge: {
        style: {
          stroke: 'violet',
          lineWidth: 4
        },
        labelCfg: {
          refX: 20,
          refY: 20,
          autoRotate: true,
          style: {
            fontSize: 18
          }
        }
      },
      nodeStateStyles: { // 节点状态
        hover: { // 状态名称
          fill: 'orange',
          'node-text': { // 配置该节点下 name 为 node-text 的图形的样式（应该是给自定义边/节点使用的）
            fill: 'blue',
            fontSize: 24
          }
        },
        'apple:red': { // 多值状态，类似命名空间
          fill: 'red'
        },
        'apple:blue': { // 多值状态，类似命名空间
          fill: 'blue'
        }
      },
      edgeStateStyles: { // 边状态
        hover: {
          fill: 'blue'
        }
      }
    });

    // 监听事件更改状态
    graph.on('node:mouseenter', (evt) => {
      const { item } = evt;

      // setItemState 第一个入参为 节点实例 或者 节点的 id。
      graph.setItemState(item, 'hover', true);
      // 多值状态
      // graph.setItemState(item, 'apple', 'red');
    });

    graph.on('node:mouseleave', (evt) => {
      const { item } = evt;
      graph.setItemState(item, 'hover', false);
      // 多值状态
      // graph.setItemState(item, 'apple', 'blue');
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```



**2. 自定义的 ``Behavior`` 中设置为定义的状态。**

详情见[交互行为](#交互行为)的代码示例部分。


### 重写 & 取消
通过 ``graph.updateItem`` 方法进行状态重写操作（如果重写的节点已经处在某种状态，重写时会直接体现出来）；通过 ``graph.clearItemStates`` 方法进行状态取消操作（支持单个或者多个状态取消）。

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 300,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        type: 'circle',
        size: 80,
        labelCfg: {
          style: {
            fill: '#fff',
            stroke: 'black',
            fontSize: 16,
          }
        },
        style: {
            fill: 'orangered',
            stroke: 'violet'
        }
      },
      defaultEdge: {
        style: {
          stroke: 'violet',
          lineWidth: 4
        },
        labelCfg: {
          refX: 20,
          refY: 20,
          autoRotate: true,
          style: {
            fontSize: 18
          }
        }
      },
      nodeStateStyles: { // 节点状态
        hover: { // 状态名称
          fill: 'orange'
        },
        'apple:red': { // 多值状态，类似命名空间
          fill: 'red'
        },
        'apple:blue': { // 多值状态，类似命名空间
          fill: 'blue'
        }
      },
      edgeStateStyles: { // 边状态
        hover: {
          fill: 'blue'
        }
      }
    });

    graph.data(data);
    graph.render();

    setTimeout(() => {
      graph.setItemState('node1', 'hover', true);
    }, 1000);

    setTimeout(() => {
      graph.updateItem('node1', {
        stateStyles: {
          hover: {
            fill: 'black'
          }
        }
      })
    }, 2000);

    setTimeout(() => {
      graph.clearItemStates('node1', 'hover');
    }, 3000);
  },
};
</script>
{% endraw %}
```



### 状态注意事项
1. 样式优先级原则：后设置的状态 > 先设置的。
> + 通过 ``hasState`` 方法判断元素状态是否激活。








### 事件
#### 基础事件
事件绑定 ``graph.on`` 与事件解绑 ``graph.off`` 。

**通用事件**

| 事件名称 | 描述 |
| :--- | :--- |
| click | 单击鼠标左键或者按下回车键时触发 |
| dblclick | 双击鼠标左键时触发，同时会触发两次 click |
| mouseenter | 鼠标移入元素范围内触发，该事件不冒泡，即鼠标移到其后代元素上时不会触发 |
| mousemove | 	鼠标在元素内部移动时不断触发，不能通过键盘触发 |
| mouseout | 	鼠标移出目标元素后触发 |
| mouseover | 鼠标移入目标元素上方，鼠标移到其后代元素上时会触发 |
| mouseleave | 鼠标移出元素范围时触发，该事件不冒泡，即鼠标移到其后代元素时不会触发 |
| mousedown | 鼠标按钮被按下（左键或者右键）时触发，不能通过键盘触发 |
| mouseup | 鼠标按钮被释放弹起时触发，不能通过键盘触发 |
| contextmenu | 用户右击鼠标时触发并打开上下文菜单 |
| dragstart | 当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上 |
| drag | 当拖拽元素在拖动过程中时触发的事件，此事件作用于被拖拽元素上 |
| dragend | 当拖拽完成后触发的事件，此事件作用在被拖曳元素上 |
| dragenter | 	当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上 |
| dragleave | 当拖曳元素离开目标元素的时候触发的事件，此事件作用在目标元素上 |
| drop | 被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 |
| keydown | 按下键盘键触发该事件 |
| keyup | 释放键盘键触发该事件 |
| wheel | 鼠标滚轮滚动时触发该事件 |
| touchstart | 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发 |
| touchmove | 当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用 ``preventDefault()`` 事件可以阻止滚动。 |
| touchend | 当手指从屏幕上离开的时候触发 |





**Node 交互事件**

| 事件名称 | 描述 |
| :--- | :--- |
| node:click | 鼠标左键单击节点时触发 |
| node:dblclick | 鼠标双击左键节点时触发，同时会触发两次 node:click |
| node:mouseenter | 鼠标移入节点时触发 |
| node:mousemove | 鼠标在节点内部移动时不断触发，不能通过键盘触发 |
| node:mouseout | 鼠标移出节点后触发 |
| node:mouseover | 鼠标移入节点上方时触发 |
| node:mouseleave | 鼠标移出节点后触发 |
| node:mousedown | 鼠标按钮在节点上按下（左键或者右键）时触发，不能通过键盘触发 |
| node:mouseup | 节点上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 |
| node:dragstart | 当节点开始被拖拽的时候触发的事件，此事件作用在被拖曳节点上 |
| node:drag | 当节点在拖动过程中时触发的事件，此事件作用于被拖拽节点上 |
| node:dragend | 当拖拽完成后触发的事件，此事件作用在被拖曳节点上 |
| node:dragenter | 当拖曳节点进入目标元素的时候触发的事件，此事件作用在目标元素上 |
| node:dragleave | 当拖曳节点离开目标元素的时候触发的事件，此事件作用在目标元素上 |
| node:dragover | 当拖曳节点在另一目标元素上移动时触发此事件，此事件作用在目标元素上 |
| node:drop | 	被拖拽的节点在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 |
| node:touchstart | 在触控屏上，当节点开始被触碰的时候触发的事件 |
| node:touchmove | 在触控屏上，当节点开始被触碰过程中触发的事件 |
| node:touchend | 在触控屏上，当节点开始被触碰结束的时候触发的事件 |
| node:contextmenu | 用户在节点上右击鼠标时触发并打开右键菜单 |



**Edge 交互事件**

| 事件名称 | 描述 |
| :--- | :--- |
| edge:click | 鼠标左键单击边时触发 |
| edge:dblclick | 鼠标双击左键边时触发，同时会触发两次 edge:click |
| edge:mouseenter | 鼠标移入边时触发 |
| edge:mousemove | 鼠标在边上移动时不断触发，不能通过键盘触发 |
| edge:mouseout | 鼠标移出边后触发 |
| edge:mouseover | 鼠标移入边上方时触发 |
| edge:mouseleave | 鼠标移出边时触发 |
| edge:mousedown | 鼠标按钮在边上按下（左键或者右键）时触发，不能通过键盘触发 |
| edge:mouseup | 边上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 |
| edge:dragenter | 当拖曳元素进入目标边元素的时候触发的事件，此事件作用在目标边元素上 |
| edge:dragleave | 当拖曳元素离开目标边元素的时候触发的事件，此事件作用在目标边元素上 |
| edge:dragover | 当拖曳元素在另一目标边上移动时触发此事件，此事件作用在目标边元素上 |
| edge:drop | 被拖拽的元素在目标边元素上同时鼠标放开触发的事件，此事件作用在目标边元素上 |
| edge:contextmenu | 用户在边上右击鼠标时触发并打开右键菜单 |







**Combo 交互事件**

Combo 继承所有 Node 事件。







**Canvas 交互事件**

| 事件名称 | 描述 |
| :--- | :--- |
| canvas:click | 鼠标左键单击画布时触发 |
| canvas:dblclick | 鼠标双击左键画布时触发 |
| canvas:mouseenter | 鼠标移入画布时触发 |
| canvas:mousemove | 鼠标在画布内部移动时不断触发，不能通过键盘触发 |
| canvas:mouseout | 鼠标移出画布后触发 |
| canvas:mouseover | 鼠标移入画布上方时触发 |
| canvas:mouseleave | 鼠标移出画布时触发 |
| canvas:mousedown | 鼠标按钮在画布上按下（左键或者右键）时触发，不能通过键盘触发 |
| canvas:mouseup | 画布上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 |
| canvas:contextmenu | 用户在画布上右击鼠标时触发并打开右键菜单 |
| canvas:dragstart | 当画布开始被拖拽的时候触发的事件，此事件作用在被拖曳画布上 |
| canvas:drag | 当画布在拖动过程中时触发的事件，此事件作用于被拖拽画布上 |
| canvas:dragend | 当拖拽完成后触发的事件，此事件作用在被拖曳画布上 |
| canvas:dragenter | 当拖曳画布进入目标元素的时候触发的事件，此事件作用在目标画布上 |
| canvas:dragleave | 当拖曳画布离开目标元素的时候触发的事件，此事件作用在目标画布上 |
| canvas:drop | 被拖拽的元素在空白画布上同时鼠标放开触发的事件，此事件作用在目标画布上 |
| canvas:touchstart | 在触控屏上，当画布开始被触碰的时候触发的事件 |
| canvas:touchmove | 在触控屏上，当画布开始被触碰过程中触发的事件 |
| canvas:touchend | 	在触控屏上，当画布开始被触碰结束的时候触发的事件 |






#### 时机事件

| 事件名称 | 描述 |
| :--- | :--- |
| beforerender | 调用 ``graph.render`` / ``graph.read`` 方法之前触发 |
| afterrender | 调用 ``graph.render`` / ``graph.read`` 方法之后触发 |
| beforedestroy | 调用 ``graph.destroy`` 方法之前触发 |
| afterdestroy | 调用 ``graph.destroy`` 方法之后触发 |
| beforechangedata | 调用 ``graph.changeData`` 方法之前触发 |
| afterchangedata | 调用 ``graph.changeData`` 方法之后触发 |
| beforeadditem | 调用 ``graph.add`` / ``graph.addItem`` 方法之前触发 |
| afteradditem | 调用 ``graph.add`` / ``graph.addItem`` 方法之后触发 |
| beforeremoveitem | 调用 ``graph.remove`` / ``graph.removeItem`` 方法之前触发 |
| afterremoveitem | 调用 ``graph.remove`` / ``graph.removeItem`` 方法之后触发 |
| beforeupdateitem | 调用 ``graph.update`` / ``graph.updateItem`` 方法之前触发 |
| afterupdateitem | 调用 ``graph.update`` / ``graph.updateItem`` 方法之后触发 |
| beforeitemvisibilitychange | 调用 ``graph.showItem`` / ``graph.hideItem`` 方法之前触发 |
| afteritemvisibilitychange | 调用 ``graph.showItem`` / ``graph.hideItem`` 方法之后触发 |
| beforeitemstatechange | 调用 ``graph.setItemState`` 方法之前触发 |
| afteritemstatechange | 调用 ``graph.setItemState`` 方法之后触发 |
| beforeitemrefresh | 调用 ``graph.refreshItem`` 方法之前触发 |
| afteritemrefresh | 调用 ``graph.refreshItem`` 方法之后触发 |
| beforeitemstatesclear | 调用 ``graph.clearItemStates`` 方法之前触发 |
| afteritemstatesclear | 调用 ``graph.clearItemStates`` 方法之后触发 |
| beforemodechange | 调用 ``graph.setMode`` / ``graph.addBehaviors`` / ``graph.removeBehaviors`` 方法之前触发 |
| aftermodechange | 调用 ``graph.setMode`` / ``graph.addBehaviors`` / ``graph.removeBehaviors`` 方法之后触发 |
| beforelayout | 布局前触发。调用 ``graph.render`` 时会进行布局，因此 ``render`` 时会触发。或用户主动调用图的 ``graph.layout`` 时触发。 |
| afterlayout | 布局完成后触发。调用 ``graph.render`` 时会进行布局，因此 ``render`` 时布局完成后会触发。或用户主动调用图的 ``graph.layout`` 时布局完成后触发。 |
| beforegraphrefreshposition | ``graph.refreshPositions`` 被调用前触发 |
| aftergraphrefreshposition | ``graph.refreshPositions`` 被调用后触发 |
| beforegraphrefresh | ``graph.refresh`` 被调用前触发 |
| aftergraphrefresh | ``graph.refresh`` 被调用后触发 |
| beforeanimate | 全局动画发生前触发 |
| afteranimate | 全局动画发生后触发 |
| beforecreateedge | 使用内置交互 ``create-edge`` ，创建边之前触发 |
| aftercreateedge | 使用内置交互 ``create-edge`` ，创建边之后触发 |
| beforecollapseexpandcombo | 当一个 ``combo`` 被收起或展开之前被触发，参数 ``action`` 指明了是收起还是展开 |
| aftercollapseexpandcombo | 当一个 ``combo`` 被收起或展开之后被触发，参数 ``action`` 指明了是收起还是展开 |
| graphstatechange | 调用 ``graph.updateItemState`` 方法之后触发 |
| afteractivaterelations | 使用了 ``'activate-relations'``  ``Behavior`` 并触发了该行为后，该事件被触发 |
| nodeselectchange | 使用了 ``'brush-select'`` ,  ``'click-select'``  或  ``'lasso-select'``   ``Behavior``  且选中元素发生变化时，该事件被触发 |
| itemcollapsed | 在  ``TreeGraph``  上使用了  ``'collapse-expand'``   ``Behavior``  并触发了该行为后，该事件被触发 |
| tooltipchange | 使用了  ``'tooltip'``  或  ``'edge-tooltip'``   ``Behavior``  且  ``tooltip``  的显示/隐藏被改变后，该事件被触发 |
| wheelzoom | 使用了  ``'zoom-canvas'``   ``Behavior``  并用滚轮对图进行缩放后，该事件被触发 |
| viewportchange | 调用  ``graph.moveTo`` ， ``graph.translate`` ，或  ``graph.zoom``  均会触发该事件 |
| dragnodeend | 使用了  ``'drag-node'``   ``Behavior`` ，当拖动结束时，该事件被触发 |
| stackchange | 撤销/重做栈发生变化时，该事件触发 |


**插件中的时机事件**

``TimeBar`` 插件

| 事件名称 | 描述 |
| :--- | :--- |
| valuechange | 时间轴的时间范围发生变化时触发 |
| timebarstartplay | 时间轴开始播放时触发 |
| timebarendplay | 时间轴播放结束时触发 |



``Tooltip`` 插件

| 事件名称 | 描述 |
| :--- | :--- |
| tooltipchange | ``Tooltip`` 发生变化时触发 |




**回调参数**

``beforerender / afterrender`` - 不涉及。


``beforeadditem``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| type | String | 当前添加的类型 |
| model | Object | item 数据模型 |


``afteradditem``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| type | String | 已经添加的 item 实例 |
| model | Object | item 数据模型 |


``beforeremoveitem / afterremoveitem``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| type | Item | 被删除的 item 实例数据 |
| type | 'node' / 'edge' / 'combo' | 被删除的 item 类型 |



``beforeupdateitem / afterupdateitem``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| type | Item | 要更新的 item 实例 |
| model | Object | item 数据模型 |



``beforeitemvisibilitychange / afteritemvisibilitychange``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| type | Item | 当前操作的 item 实例 |
| visible | Boolean | 是否可见，true 为可见，false 为不可见 |



``beforeitemstatechange / afteritemstatechange``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| type | Item | 当前操作的 item 实例 |
| state | String | 状态 |
| enabled | Boolean | 状态是否可用，true 可用，false 不可用 |


``beforeitemstatesclear / afteritemstatesclear``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| item | Item | 当前操作的 item 实例 |
| states | Array / String | 需要批量清除的状态 |


``beforemodechange / aftermodechange``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| mode | String | 当前的模式名称 |


``beforeitemrefresh / afteritemrefresh``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| item | 	Item | 当前操作的 item 实例 |



``beforelayout / afterlayout`` - 不涉及



``graphstatechange``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| states | 	Object | 当前各个状态下的元素，格式举例 { hover: [Node, Node], selected: [ Node ] } |



``afteractivaterelations``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| item | Item | 当前操作的 item 实例 |
| action | String | 当前操作名 |


``nodeselectchange``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| target | 	Item | 当前操作的 item 实例 |
| selectedItems | Object | 当前被选中的所有 item 实例，形如 { nodes: [...], edges: [...]} |


``beforecreateedge / aftercreateedge``

``beforecreateedge`` 不涉及。

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| edge | 	Item | 当前被创建的边实例 |


``beforecollapseexpandcombo / aftercollapseexpandcombo``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| action | 	string | 具体的操作， 'collapse' 或 'expand' |
| combo | Item | 被操作的 combo item |


``itemcollapsed``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| item | 	Item | 当前操作的 item 实例 |
| collapsed | Boolean | 当前操作后，操作对象的 collapsed 状态 |


``tooltipchange``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| item | 	Item | 当前操作的 item 实例 |
| action | String | tooltip 当前是显示 'show' 还是隐藏 'hide' |

``wheelzoom``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| deltaX | 	Number | 滚动的 x 方向，取值 1，0，-1，0 代表没有该方向的滚动 |
| deltaY | Number | 滚动的 y 方向，取值 1，0，-1，0 代表没有该方向的滚动 |

``viewportchange``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| action | 	'translate' / 'move' / 'zoom' | 视窗变换的类型，'translate'、'move'、'zoom' 分别标识该时机是由 graph.translate、graph.move、还是 graph.zoom 函数的调用而产生 |
| matrix | Array | 视窗变换后的图的矩阵 |


``dragnodeend``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| items |	Item[] | 当前操作的 item 实例 |
| targetItem | null/Node/Combo | 拖动节点结束后，节点是放到 canvas、Node 还是 Combo 上面 |


``stackchange``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| redoStack |	Object[] | 重做堆栈 |
| undoStack | Object[] | 撤销堆栈 |
| action | String | 操作类型 |
| stackType | String | 栈变更类型，撤销 undo / 重做 redo |


``valuechange``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| value |	number[] | 时间轴当前时间范围，value[0] 为起始值，value[1] 为结束值 |



``timelinestart / timelineend`` - 不涉及


``tooltipchange``

| 名称 | 类型 | 描述 |
| :--- | :--- | :--- |
| item | Item | tooltip 所关联的元素（节点/边） |
| action | 'show' / 'hide' | tooltip 当前的变化时显示还是隐藏 |






## 进阶
### 自定义节点
[官网文档](https://g6-v4.antv.vision/manual/middle/elements/nodes/custom-node)

``G6`` 提供了一系列内置节点，包括 ``circle、rect、diamond、triangle、star、image、modelRect`` 。若内置节点无法满足需求，用户还可以通过 ``G6.registerNode(typeName: string, nodeDefinition: object, extendedNodeType?: string)`` 进行自定义节点，方便用户开发更加定制化的节点。

**自定义节点的 API 如下：**
```javascript
G6.registerNode(
  'nodeName',
  {
    options: {
      style: {},
      stateStyles: {
        hover: {},
        selected: {},
      },
    },
    /**
     * 绘制节点，包含文本
     * @param  {Object} cfg 节点的配置项
     * @param  {G.Group} group 图形分组，节点中图形对象的容器
     * @return {G.Shape} 返回一个绘制的图形作为 keyShape，通过 node.get('keyShape') 可以获取。
     * 关于 keyShape 可参考文档 核心概念-节点/边/Combo-图形 Shape 与 keyShape
     */
    draw(cfg, group) {},
    /**
     * 绘制后的附加操作，默认没有任何操作
     * @param  {Object} cfg 节点的配置项
     * @param  {G.Group} group 图形分组，节点中图形对象的容器
     */
    afterDraw(cfg, group) {},
    /**
     * 更新节点，包含文本
     * @override
     * @param  {Object} cfg 节点的配置项
     * @param  {Node} node 节点
     */
    update(cfg, node) {},
    /**
     * 更新节点后的操作，一般同 afterDraw 配合使用
     * @override
     * @param  {Object} cfg 节点的配置项
     * @param  {Node} node 节点
     */
    afterUpdate(cfg, node) {},
    /**
     * 响应节点的状态变化。
     * 在需要使用动画来响应状态变化时需要被复写，其他样式的响应参见下文提及的 [配置状态样式] 文档
     * @param  {String} name 状态名称
     * @param  {Object} value 状态值
     * @param  {Node} node 节点
     */
    setState(name, value, node) {},
    /**
     * 获取锚点（相关边的连入点）
     * @param  {Object} cfg 节点的配置项
     * @return {Array|null} 锚点（相关边的连入点）的数组,如果为 null，则没有控制点
     */
    getAnchorPoints(cfg) {},
  },
  // 继承内置节点类型的名字，例如基类 'single-node'，或 'circle', 'rect' 等
  // 当不指定该参数则代表不继承任何内置节点类型
  extendedNodeType,
);
```

**自定义节点的定义 demo 如下：**

![g6_03](/static/img/g6/g6_09.gif)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义方块节点
    G6.registerNode('custom-rect', {
      draw(cfg, group) {
        const keyShap = group.addShape('rect', {
          name: '大方块',
          attrs: {
            width: 60,
            height: 40,
            x: 0,
            y: 0,
            fill: 'red',
            stroke: 'blue'
          }
        });

        group.addShape('rect', {
          name: '小方块',
          attrs: {
            width: 40,
            height: 20,
            x: 10,
            y: 10,
            fill: 'orange',
            stroke: 'black'
          }
        });


        return keyShap;
      },
      /**
       * 1. 当图中节点或边通过  graph.update(item, cfg) 重绘时，默认情况下会调用节点的 draw 方法进行重新绘制。
       * 在数据量大或节点上图形数量非常多（特别是文本多）的情况下，draw 方法中对所有图形、赋予样式将会非常消耗性能。
       * 2. 在自定义节点时，重写  update 方法，在更新时将会调用该方法替代 draw。
       * 我们可以在该方法中指定需要更新的图形，从而避免频繁调用  draw 、全量更新节点上的所有图形。
       * 3. update 方法是可选的，如果没有性能优化的需求可以不重写该方法。
       * 
       **/
      update(cfg, node) {
        const group = node.getContainer(); // 获取引用组
        const bigRect = group.get('children')[0]; // 按照添加的顺序获取
        // const smallRect = group.get('children')[1]; // 按照添加的顺序获取

        // 更新通过 graph.update(item, cfg) 方法节点时读取传递的参数进行更新
        bigRect.attr({ fill: cfg.fill });
      },
      /**
       *指定锚点：锚点可以指定多个，每个数组项为连接点第一项为 x 第二项为 y，0/0.5/1 三个值 
       **/
      getAnchorPoints() {
        return [
          [0, 0.5], // 左中
          [1, 0.5] // 右中
        ]
      },
      /**
       *设置状态更新，简易使用此方法，不建议通过 options 里 stateStyles 对象配置
       **/
      setState(name, value, node) {
        const group = node.getContainer(); // 获取引用组
        const bigRect = group.get('children')[0]; // 按照添加的顺序获取

        if (name === 'hover') {
          if (value) {
            bigRect.attr('fill', 'gainsboro');
          } else {
            bigRect.attr('fill', 'orange');
          }
        }
      }
    });

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 80,
          label: '起始点',
          labelCfg: {
            style: {
              fontSize: 18,
              fill: '#fff'
            }
          },
          style: {
            fill: 'blue'
          }
        },
        {
          id: 'node2',
          type: 'custom-rect',
          x: 300,
          y: 200,
          label: '中间点'
        },
        {
          id: 'node3',
          type: 'custom-rect',
          x: 500,
          y: 200,
          label: '结束点'
        },
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        },
        {
          id: '2-3',
          source: 'node2',
          target: 'node3',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
    });

    // 悬停时，更改自定义节点的状态，调用 注册方法里面的 setState 方法处理
    graph.on('node:mouseenter', e => {
      const node = e.item;

      graph.setItemState(node, 'hover',  !node.hasState('hover'));
    });
    graph.data(data);
    graph.render();

    setTimeout(() => {
      // 更新自定义节点 custom-rect 样式，由于有定义 update 方法，会走该方法更新
      graph.update('node2', { fill: 'pink' });
    }, 2000);
  },
};
</script>
{% endraw %}
```

**使用 DOM 自定义节点，如下：**

![g6_10](/static/img/g6/g6_10.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义方块节点
    G6.registerNode('custom-dom-rect', {
      draw(cfg, group) {
        return group.addShape('dom', {
          attrs: {
            width: cfg.size,
            height: cfg.size,
            // 传入 DOM 的 html
            html: `<div style="width: 60px;height: 40px;background-color: orange">自定义节点</div>`,
          },
          // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
          name: 'dom-node-keyShape'
        });
      },
      /**
       *指定锚点：锚点可以指定多个，每个数组项为连接点第一项为 x 第二项为 y，0/0.5/1 三个值 
       **/
      getAnchorPoints() {
        return [
          [0, 0.5], // 左中
          [1, 0.5] // 右中
        ]
      }
    });

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 80,
          label: '起始点',
          labelCfg: {
            style: {
              fontSize: 18,
              fill: '#fff'
            }
          },
          style: {
            fill: 'blue'
          }
        },
        {
          id: 'node2',
          type: 'custom-dom-rect',
          x: 300,
          y: 200,
          size: 80,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      renderer: 'svg',
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```
> + 仅在 ``Graph`` 的 ``renderer`` 为  ``'svg'`` 时可以使用。
+ 使用 'dom' 进行自定义的节点或边，不支持 G6 的交互事件，请使用原生 DOM 的交互事件。
+ 在 ``Safari`` 中，若 ``dom`` 节点被设置了 ``position:relative`` 将会导致渲染异常。[Issue](https://github.com/antvis/G6/issues/2990)。


### 自定义边
[官网文档](https://g6-v4.antv.vision/manual/middle/elements/edges/custom-edge)

**自定义边的 API 如下：**

```vue
{% raw %}
<script>
G6.registerEdge(
  'edgeName',
  {
    /**
     * 绘制边，包含文本
     * @param  {Object} cfg 边的配置项
     * @param  {G.Group} group 图形分组，边中的图形对象的容器
     * @return {G.Shape} 绘制的图形，通过 node.get('keyShape') 可以获取到
     */
    draw(cfg, group) {},
    /**
     * 绘制后的附加操作，默认没有任何操作
     * @param  {Object} cfg 边的配置项
     * @param  {G.Group} group 图形分组，边中的图形对象的容器
     */
    afterDraw(cfg, group) {},
    /**
     * 更新边，包含文本
     * @override
     * @param  {Object} cfg 边的配置项
     * @param  {Edge} edge 边
     */
    update(cfg, edge) {},
    /**
     * 更新边后的操作，一般同 afterDraw 配合使用
     * @override
     * @param  {Object} cfg 边的配置项
     * @param  {Edge} edge 边
     */
    afterUpdate(cfg, edge) {},
    /**
     * 设置边的状态，主要是交互状态，业务状态请在 draw 方法中实现
     * 单图形的边仅考虑 selected、active 状态，有其他状态需求的用户自己复写这个方法
     * @param  {String} name 状态名称
     * @param  {Object} value 状态值
     * @param  {Edge} edge 边
     */
    setState(name, value, edge) {},
  },
  'extendedEdgeName',
);
</script>
{% endraw %}
```




**直接使用 Path 生成边路径，如下：**

![g6_10](/static/img/g6/g6_11.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义方块节点
    G6.registerEdge('custom-edge', {
      draw(cfg, group) {
        const {
          startPoint: {
            x: sx,
            y: sy
          },
          endPoint: {
            x: ex,
            y: ey
          }
        } = cfg;

        return group.addShape('path', {
          attrs: {
            stroke: 'orange',
            // 使用路径画一个直角边
            path: [
              ['M', sx, sy], // 起点 M 是 svg 矢量图里面常用的命令，表示把画笔移动(Move)到某个坐标上
              ['L', sx + (ex - sx) / 2, sy + (ex - sx) / 2], // 划线，L 是 svg 矢量图里面常用的命令，表示画一条直线(Line)到某个坐标上停止
              ['L', ex, ey]
            ]
          },
          // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
          name: 'custom-edge-keyShape'
        });
      }
    });

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 400,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          type: 'custom-edge',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        size: 80,
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'blue'
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```




**增加图形 & 文字，如下：**

![g6_12](/static/img/g6/g6_12.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义方块节点
    G6.registerEdge('custom-edge-square-text', {
      draw(cfg, group) {
        const {
          startPoint: {
            x: sx,
            y: sy
          },
          endPoint: {
            x: ex,
            y: ey
          }
        } = cfg;
        const width = 60;
        const height = 30;

        const keyShape = group.addShape('path', {
          attrs: {
            stroke: 'orange',
            path: [
              ['M', sx, sy],
              ['L', ex, ey]
            ]
          },
          // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
          name: 'custom-edge-path'
        });

        // 添加方块
        group.addShape('rect', {
          attrs: {
            stroke: 'green',
            lineWidth: 4,
            width,
            height,
            fill: 'orangered',
            x: sx + (ex - sx) / 2 - width / 2,
            y: sy + (ey - sy) / 2 - height / 2
          },
          // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
          name: 'custom-edge-square'
        });

        const fontSize = 12;

        // 添加文字
        group.addShape('text', {
          attrs: {
            text: cfg.label,
            fill: '#fff',
            fontSize,
            textAlign: 'center',
            x: sx + (ex - sx) / 2, // x 和 y 以添加的第一个图形为准
            y: sy + (ey - sy) / 2 + fontSize / 2
          },
          // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
          name: 'custom-edge-text'
        });

        return keyShape;
      }
    });

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 400,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          type: 'custom-edge-square-text',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        size: 80,
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'blue'
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```





**通过第三个入参设置为已有边类型跳过边的绘制，再通过 afterDraw 回调函数添加 图形 和 文字，如下：**

![g6_13](/static/img/g6/g6_13.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义方块节点
    G6.registerEdge('custom-edge-square-text',
      {
        afterDraw(cfg, group) {
          // 获取图形组中的第一个图形，在这里就是边的路径图形
          const shape = group.get('children')[0];
          // 获取路径图形的中点坐标
          const { x, y } = shape.getPoint(0.5);

          // 添加方块
          const width = 80;
          const height = 30;

          group.addShape('rect', {
            attrs: {
              width: 80,
              height: 30,
              lineWidth: 4,
              x: x - width / 2,
              y: y - height / 2,
              stroke: 'green',
              fill: 'orangered'
            },
            // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
            name: 'custom-edge-square'
          });

          const fontSize = 12;

          // 添加文字
          group.addShape('text', {
            attrs: {
              text: cfg.label,
              fill: '#fff',
              fontSize,
              textAlign: 'center',
              x, // x 和 y 以添加的第一个图形为准
              y: y + fontSize / 2
            },
            // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
            name: 'custom-edge-text'
          });
        },
        update: undefined
      },
      'cubic' // 通过继承已有的 边，跳过 draw 方法
    );

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 400,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          type: 'custom-edge-square-text',
          label: '我是连线',
          style: {
            lineWidth: 4,
            stroke: 'violet'
          }
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        size: 80,
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'blue'
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```
> + 通过配置 ``G6.registerEdge`` 第三个参数来继承已有的内置边，只在 ``afterDraw`` 中添加额外内容。





**边的交互 & 自定义箭头**

**<font color=red>注：3.4.1 版本之后，箭头的指向有 x 轴的正方向改为了 x 轴的负方向。</font>**

![g6_14](/static/img/g6/g6_14.jpg)

![g6_15](/static/img/g6/g6_15.gif)

右箭头的颜色变化是单独设置的。

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义边
    G6.registerEdge('custom-edge-arrow',
      {
        draw(cfg, group) {
          const {
            startPoint: {
              x: sx,
              y: sy
            },
            endPoint: {
              x: ex,
              y: ey
            }
          } = cfg;

          return group.addShape('path', {
            attrs: {
              path: [
                ['M', sx, sy],
                ['L', ex, ey] // 结束连线保留 20 的空白间距
              ],
              stroke: 'red',
              lineWidth: 4,
              startArrow: {
                path: 'M 0,0 L 20,10 L 20,-10 Z', // svg 语法 Z 表示闭合路径
                fill: 'blue'
              },
              endArrow: {
                path: 'M 40,0 L 60,10 L 60,-10 Z', // svg 语法 Z 表示闭合路径
                fill: 'green',
                lineWidth: 2,
                stroke: 'orange',
                d: 20 // 保留 20 的留白，需要把 调整 M 和 L
              }
            },
            name: 'custom-edge-path'
          });
        },
        setState(name, value, item) {
          const group = item.getContainer();
          const keyShape = group.get('children')[0];

          const attr = keyShape.attr(); // 获取配置项

          if (name === 'hover') {
            if (value) {
              keyShape.attr('stroke', 'black'); // 单个属性更新

              const endArrow = attr.endArrow;
              
              endArrow.stroke = 'red'; // 重写箭头样式
              keyShape.attr({ // 传入对象，批量更新
                stroke: 'black',
                endArrow: {
                  ...endArrow // 一定要进行深克隆，否则无效
                }
              });
            } else {
              keyShape.attr('stroke', 'red');
            }
          }
        }
      }
    );

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 400,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          type: 'custom-edge-arrow',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        size: 80,
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'blue'
          }
        }
      }
    });

    graph.on('edge:mouseenter', e => {
      const item = e.item;

      graph.setItemState(item, 'hover', !item.hasState('hover'));
    });
    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```
> **<font color=red>使用 keyShape.attr 方法通过传入对象进行批量更新的时候如果要复用之前的配置，需要进行深克隆后传递。</font>**。





### 交互行为
``Behavior`` 是 ``G6`` 提供的定义图上交互事件的机制。




**内置 Behavior**

[官方文档](https://g6-v4.antv.vision/manual/middle/states/default-behavior#%E4%BB%80%E4%B9%88%E6%98%AF-behavior)

demo 示例
```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 400,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      // 交互行为
      modes: {
        default: [
          {
            type: 'tooltip', // 节点 tooltip，可以返回文本/html
            formatText(model) {
              return model.label;
            },
            offset: 10
          },
          {
            type: 'edge-tooltip', // 节点 tooltip，可以返回文本/html
            formatText(model) {
              return model.label;
            },
            offset: 10
          },
          {
            type: 'activate-relations' // 与激活状态的节点关联的节点都高亮
          }
        ]
      },
      defaultNode: {
        size: 80,
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'blue'
          }
        }
      },
      defaultEdge: {
        labelCfg: {
          refY: 50,
          style: {
            fontSize: 18,
            fill: 'red'
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```


1\. ``drag-combo`` 拖拽 combo

2\. ``collapse-expand-combo`` 折叠 combo 

3\. ``drag-canvas`` 拖拽画布
> 对应的事件： ``canvas:dragstart`` / ``canvas:drag`` / ``canvas:dragend`` 。


4\. ``scroll-canvas`` 滚动画布（没有浏览器滚动条的滚动直观）
> 对应的事件： ``onWheel`` 。

5\. ``zoom-canvas`` 缩放画布
> 对应的事件： ``wheelzoom`` 。

6\. ``drag-node`` 拖动节点

7\. ``click-select`` 点击选中节点
> 对应的事件： ``nodeselectchange`` 。

8\. ``tooltip``  节点文本提示
> 需要自定义样式，类名为 ``.g6-tooltip`` 和 ``.g6-node-tooltip`` 。

9\. ``edge-tooltip`` 边文本提示
> 需要自定义样式，类名为 ``.g6-tooltip`` 和 ``.g6-edge-tooltip`` 。

10\. ``activate-relations`` 当鼠标移到某节点时，突出显示该节点以及与其直接关联的节点和连线
> 对应的事件： ``afteractivaterelations`` 。

11\. ``brush-select`` 框选节点
> 对应的事件： ``nodeselectchange`` 

12\. ``lasso-select`` 自由圈选
> 对应的事件： ``nodeselectchange`` 

13\. ``collapse-expand`` 只适用于树图，展开或收起子树
> 对应的事件： ``itemcollapsed`` 

14\. ``create-edge`` 通过交互创建边
> 对应的事件： ``aftercreateedge`` 

15\. ``shortcuts-call`` 允许终端用户使用键盘组合键调用 Graph 的函数，例如按下键盘上的 control 与 1，对图进行适应画布
> **<font color=red>注意：终端用户使用该功能时焦点必须在画布上才能够正确触发；</font>**





**自定义 Behavior**
[自定义交互示例](https://g6-v4.antv.vision/manual/middle/states/custom-behavior)/[自定义交互API](https://g6-v4.antv.vision/api/behavior)


```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    G6.registerBehavior('b-active', {
      // 非必填，数据会混入每个节点数据非共享
      getDefaultCfg() {
        return {
          status: true
        };
      },
      getEvents() {
        return {
          // value 的命名非固定写法可自定义，只要 配置项有同名方法即可
          'node:click': 'onNodeClick'
        };
      },
      onNodeClick(e) {
        const node = e.item;
        const group = node.getContainer();

        if (!this.shouldBegin(e, this.graph)) {
          return;
        }

        // graph 内置绑定到 this 上下文
        this.graph.setItemState(node, 'b-hover', !node.hasState('b-hover'));

        // 单独配置节点状态外的样式 - 文字
        const nodeText = group.get('children')[1];

        if (node.hasState('b-hover')) {
          nodeText.attr('fill', '#fff');
        } else {
          nodeText.attr('fill', 'blue');
        }
      },
      // 优先级低于 modes 配置的同名函数
      shouldBegin(e, self) {
        if (e.item.getModel().id === 'node2') {
          return false;
        }

         return true;
      },
      // 优先级低于 modes 配置的同名函数
      // shouldUpdate(e, self) {},
      // 优先级低于 modes 配置的同名函数
      // shouldEnd(e, self) {}
    });
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 400,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      modes: {
        default: [
          {
            type: 'b-active',
            // 优先级高于 registerBehavior 注册函数的配置项同名方法
            // shouldBegin(e, self) {},
            // 优先级高于 registerBehavior 注册函数的配置项同名方法
            shouldUpdate(e, self) {},
            // 优先级高于 registerBehavior 注册函数的配置项同名方法
            shouldEnd(e, self) {}
          }
        ]
      },
      defaultNode: {
        size: 80,
        style: {
          fill: 'orange'
        },
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'blue'
          }
        }
      },
      defaultEdge: {
        labelCfg: {
          refY: 50,
          style: {
            fontSize: 18,
            fill: '#333'
          }
        }
      },
      nodeStateStyles: {
        'b-hover': {
          fill: 'red'
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```





**相关 API**

| 方法名 | 用途 |
| :--- | :--- |
| graph.addBehaviors('drag-canvas', 'default') | 添加行为，参数1支持数组批量添加 |
| graph.setMode('edit') | 切换模式 |
| graph.removeBehaviors('drag-canvas', 'default') | 移除行为 |






## 图形分组

[官网文档](https://g6-v4.antv.vision/api/group)
图形分组 ``Graphics Group`` （下文简称  ``Group`` ） 类似于 ``SVG`` 中的  ``<g>`` 标签：``Group`` 是用来组合图形对象的容器。

**获取  ``group`` 分组对象的引用**

``node/edge/combo.getContainer()`` 或 ``node/edge/combo.get('group')``。

**涉及的 API 如下：**

| 名称 | 用途 | 注意事项 |
| : --- | :--- | :--- |
| group.addGroup(cfg) | 向分组中添加新的分组 | 1.入参为非必填。<br />2.返回子分组，使用子分组继续添加图形。 |
| group.addShape(type, cfgs) | 向分组中添加新的图形 | 自定义节点边、边、箭头常用此方法 |
| group.contain(child)) | 该分组是否包含此元素 | 入参为 子 ``Group`` 或 ``Shape`` 的实例 |
| group.find(fn) | 根据指定条件返回对应元素，只返回符合条件的第一个元素。 | 入参为自定义回调函数 |
| group.findById(id) | 根据元素 ``ID`` 返回对应的实例。 | ``Group`` 实例 ``ID`` |
| group.findAll(fn) | 返回所有符合条件的元素。 | 返回数组 |
| group.getShape(x,y) | 返回该坐标点最上层的元素。 | - |
| group.getFirst() | 获取该分组的第一个子元素。 | - |
| group.getLast() | 获取该分组的最后一个子元素。 | - |
| group.getChildByIndex(index) | 返回第 ``index`` 个子元素，从 0 开始计数。 | - |
| group.removeChild(child) | 从分组中删除一个分组或一个图形。 | - |
| group.sort() | 排序方法。 | 一般用于在设置子元素层叠顺序时使用（使用 group.addShape 时，给每个图形都设置了 index 值，最后调用此方法进行排序）。 |
| group.clear() | 清除该组的所有子元素。 | - |

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义方块节点
    G6.registerNode('custom-rect', {
      draw(cfg, group) {
        const keyShap = group.addShape('rect', {
          id: 'bigRect',
          name: '大方块',
          attrs: {
            width: 60,
            height: 40,
            x: 0,
            y: 0,
            fill: 'red',
            stroke: 'blue'
          }
        });

        group.addShape('rect', {
          name: '小方块',
          attrs: {
            width: 40,
            height: 20,
            x: 10,
            y: 10,
            fill: 'orange',
            stroke: 'black'
          }
        });

        // 添加分组
        const subGroup = group.addGroup({
          id: 'subGroupId',
          name: 'subGroupName'
        });

        // 子 group 进行添加（添加的形状索引为 3，当前自组的索引为 2）
        subGroup.addShape('circle', {
          name: '小圆',
          attrs: {
            r: 5,
            x: 30,
            y: 20,
            fill: 'blue',
            stroke: 'black'
          }
        });

        return keyShap;
      }
    });

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          type: 'custom-rect',
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 80,
          label: '起始点'
        },
        {
          id: 'node2',
          type: 'custom-rect',
          x: 300,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultEdge: {
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'violet'
          }
        }
      }
    });

    // 悬停时，更改自定义节点的状态，调用 注册方法里面的 setState 方法处理
    graph.on('node:mouseenter', e => {
      const node = e.item;
      const group = node.getContainer();

      // 通过 id 查找子组或者图形
      // console.log(group.findById('subGroupId'));

      // 通过回调函数查找（图形、子组）
      const subGroup = group.find(item => {
        return item.get('name') === 'subGroupName';
      });
    });
    graph.data(data);
    graph.render();
  }
};
</script>
{% endraw %}
```
> **<font color=red>group.addGroup 添加子组，子组继续添加图形，图形属性是线性的不是递归的，比如：子组的索引为 2，增加一个图形后，图形的索引就是 3，以此类推。</font>**


### Tooltip
Tooltip 插件主要用于在节点和边上展示一些辅助信息，**<font color=red>G6 4.0 以后，Tooltip 插件将会替换 Behavior 中的 tooltip。</font>**

[官网文档](https://g6-v4.antv.vision/api/plugins#tooltip)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    const tooltip = new G6.Tooltip({
      offsetX: 10,
      offsetY: 10,
      trigger: 'mounseenter', // 可以设置：'mouseenter' / 'click'
      // fixToNode: [10, 10], // 是否固定出现在节点的某个位置，默认为 false
      getContent(e) {
        const div = document.createElement('div');

        div.style.padding = 10;
        div.innerHTML = `${e.item.getModel().label}`;

        return div;
      },
      itemTypes: ['node', 'edge'] // 可设置：'node', 'edge', 'combo'
    });

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 300,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };
    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      plugins: [tooltip], // 使用 tooltip 插件
      defaultNode: {
        size: 80,
        style: {
          fill: 'violet'
        },
        labelCfg: {
          style: {
            fontSize: 18,
            fill: '#fff'
          }
        }
      },
      defaultEdge: {
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'violet'
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```

> + **<font color=red>可以使用绝对定位的 div 元素通过，node:mousenter 和 edge:mouseenter 实现提示层。</font>**
+ 4.0 以后，优先级高于 ``modes.default: ['tooltip']`` 的配置。

## api

| 名称 | 用途 | 注意事项 |
| : --- | :--- | :--- |
| graph.getCanvasBBox | 获取画布中元素的整体宽和高（e.g. 画布中树形结构的图形的宽高） | [5 版本](https://github.com/antvis/G6/issues/5938)后方法改为 ``graph.getCanvas().getBounds('elements').halfExtents`` 数组第一项是元素的宽的一半，第二项是元素的高的一半 |
| node/edge.getContainer | 获取 group 组合的引用 | 1.group.get('children')[0] 数组的索引为添加图形的先后顺序，如果是自定节点或者边，索引为添加顺序，默认节点和边路径为 0，文本为 1。<br />2.等价于 item.get('group')。 |
| node/edge.getModel | 获取节点、边的数据信息 | 等价于 node/edge.get('model') |
| graph.getPointByClient | 页面坐标渲染为节点坐标 | - |
| graph.addItem | 节点/边添加到画布中 | - |
| graph.find | 查找节点或者边 | 1.回调函数通过 node.get('model') 拿到数据进行详细判断，e.g. x y 坐标。<br />2.返回第一个匹配的元素。 |


