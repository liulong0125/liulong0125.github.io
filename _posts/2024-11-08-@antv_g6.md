---
layout: post
title: G6
categories: [G6]
tags: [G6, 数据可视化]
---

``G6`` 简介：强分析、高性能、易扩展的图可视分析引擎。[蚂蚁数据可视化官网](https://antv-2018.alipay.com/zh-cn/index.html)、[G6官网](https://g6.antv.antgroup.com/)、[关于G6](https://antv-2018.alipay.com/zh-cn/g6/3.x/index.html)、[版本5示例](https://g6.antv.antgroup.com/examples)、[版本4示例](https://g6-v4.antv.vision/examples#net-dagreFlow)、[版本4简介](https://g6-v4.antv.vision/manual/introduction)、[版本4 api](https://g6-v4.antv.vision/api/Graph)


**<font color=red>注：本教程的所有 demo 都是基于 @antv/g6 的 4.8.24 版本。</font>**


# G6
+ [基础](#基础)
  + [点和边的配置](#点和边的配置)
  + [箭头的配置](#箭头的配置)
  + [Combo 节点分组](#combo-节点分组)
  + [聚类轮廓包裹](#聚类轮廓包裹)
  + [布局的配置](#布局的配置)
    + [默认布局](#默认布局)
    + [随机布局](#随机布局)
    + [层次布局(流程图)](#层次布局流程图)
  + [状态](#状态)
    + [配置时机](#配置时机)
    + [调用时机](#调用时机)
    + [重写 & 取消](#重写--取消)
    + [状态注意事项](#状态注意事项)
  + [事件](#事件)
+ [进阶](#进阶)
  + [自定义节点](#自定义节点)
  + [自定义边](#自定义边)
+ [api](#api)
  + [getCanvasBBox](#getcanvasbbox)



## 基础
### 点和边的配置
![g6_03](/static/img/g6/g6_03.jpg)

```vue
{% raw %}
<template>
  <div ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 120, // 节点的大小
          type: 'path', // 内置（circle/ellipse/image/rect/path/marker/polygon）/自定义节点类型（默认为 circle）
          label: '起始点', // 文本文字
          anchorPoints: [ // 连接点数组
            [0.5, 0]
          ],
          labelCfg: { // 文本样式
            // 'center'，'top'，'left'，'right'，'bottom'，内置 ModelRect（方卡片）类型不支持该属性
            position: 'center',
            // 文本的偏移，position 为 'bottom' 时，文本的上方偏移量；position 为 'left' 时，文本的右方偏移量；以此类推在其他 position 时的情况。modelRect 节点的 offset 为左边距
            // offset: 0,
            style: {
              // 通用属性
              name: 'n1',
              fill: '#fff',
              stroke: 'black',
              lineWidth: 4, // 描边大小
              // lineDash: [2, 2], // 虚线：第1项线条长度、第2项间隔长度
              shadowColor: 'orange',
              shadowBlur: 2,
              shadowOffsetX: 0,
              shadowOffsetY: 0,
              opacity: 1,
              fillOpacity: 1,
              strokeOpacity: 1,
              cursor: 'pointer',

              // 文本特有属性
              // text: '优先级高于节点的 label 属性', // 会替换 label 的文本内容
              textAlign: 'center', // center / end / left / right / start
              textBaseline: 'bottom', // top / middle / bottom
              fontStyle: 'italic', // italic / normal
              // fontVariant: 'normal', // css 样式（不常用）
              fontWeight: 'bold',
              fontSize: 30,
              fontFamily: 'Microsoft YaHei',
              lineHeight: 30, // 单行文本体现不出来
              // 需要设置 renderer 为 'svg' 方可配置 html，使用 Html 事件只能用 dom 事件
              // html: '<div></div>'
            }
          },
          style: {
              // 通用属性
              name: 'n1',
              fill: 'orangered',
              stroke: 'violet',
              lineWidth: 10, // 描边大小
              lineDash: [2, 2], // 虚线：第1项线条长度、第2项间隔长度
              shadowColor: 'black',
              shadowBlur: 2,
              shadowOffsetX: 1,
              shadowOffsetY: 1,
              opacity: 1,
              fillOpacity: 1,
              strokeOpacity: 1,
              cursor: 'pointer',

              // 圆形特有属性
              // x: 100, // 圆心 x 位置
              // y: 100, // 圆心 y 位置
              // r: 90, // 圆半径（优先级高于 size 配置）

              // 椭圆形特有属性
              // x: 100,
              // y: 80,
              // rx: 100, // 水平半径
              // ry: 140 // 垂直半径

              // 图片特有属性
              // x: 0, // 图片左上角 x 位置
              // y: 0, // 图片左上角 y 位置
              // width: 80,
              // height: 80,
              // img: '/image/logo.png', // 图片 url

              // 标记图形 Marker 特有属性
              // x: 20,
              // y: 20,
              // r: 50,
              // // 内置形状 circle/square/diamond/triangle/triangle-down，也可以是函数返回路径
              // symbol: 'triangle',

              // 多边形特有属性
              // points: [
              //   [30, 30],
              //   [40, 20],
              //   [30, 50],
              //   [60, 100]
              // ]
              
              // 矩形特有属性
              // x: 0,
              // y: 0,
              // width: 100,
              // height: 80,
              // radius: 20

              // 路径特有属性
              path: [
                ['M', 100, 100],
                ['L', 200, 200]
              ],
              startArrow: true, // 也可以是自定义箭头
              endArrow: true,
              lineAppendWidth: 10, // 边的击中范围，增加点击范围
              lineCap: 'miter', // 设置线条的结束端点样式 bevel(斜角)round(圆角)miter(尖角 (默认))
              lineJoin: 'miter', // 设置两条线相交时，所创建的拐角形状（枚举值同上）
              lineWidth: 10, // 线条宽度
              // miterLimit: 5, // 设置最大斜接长度
              // lineDash: [2, 2] // 虚线
          }
        },
        {
          id: 'node2',
          x: 500,
          y: 200,
          size: 60,
          size: 120,
          label: '目标点',
          labelCfg: {
            style: {
              fontSize: 24
            }
          }
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线',
          type: 'loop', // line/polyline/quadratic/cubic/arc/loop 以是内置边的类型名称，也可以是自定义边的名称
          // sourceAnchor: 0, // 起点的连接点的索引
          // targetAnchor: 0, // 终点点的连接点的索引
          // color: 'orange', // 优先级低于 style.stroke
          style: {
            // 通用属性
            name: 'l1-2',
            stroke: 'violet',
            lineWidth: 10, // 描边大小
            lineDash: [8, 2], // 虚线：第1项线条长度、第2项间隔长度
            shadowColor: 'black',
            shadowBlur: 2,
            shadowOffsetX: 1,
            shadowOffsetY: 1,
            // opacity: 0.1,
            // strokeOpacity: 1, // 优先级高于 opacity
            cursor: 'pointer'
          },
          labelCfg: {
            refX: 20,
            refY: 20,
            position: 'middle', // start/middle/end
            autoRotate: true,
            style: {
              fontSize: 18
            }
          },
          // stateStyles: {} // 略

          // 内置边 polyline 特有属性
          // routeCfg: {
          //   gridSize: 10, // 指定精度
          //   maxAllowedDirectionChange: Math.PI / 2, // 允许的最大转角，弧度制
          //   // obstacles: [graph.findById('node1'), graph.findById('node2')], // 需要躲避的障碍节点对象
          // },
          // style: {
          //   offset: 20,  // 拐弯处距离节点最小距离
          //   radius: 10,  // 拐弯处的圆角弧度，若不设置则为直角
          // },
          // 控制点数组 - 不指定时根据 A* 算法自动生成折线。若指定了，则按照 controlPoints 指定的位置进行弯折。示例：[{ x: 10, y: 20 }, { x: 20, y: 25 }, ...]
          // controlPoints: [{ x: 10, y: 20}],

          // 内置边 quadratic 特有属性
          // controlPoints: [{ x: 40, y: 40 }], // 控制点（photoshop 中的钢笔工具的路径点）
          // curvePosition: 0.1, // 优先级低于 controlPoints，控制点的位置比例
          // 控制点距离两端点连线的距离，可理解为控制边的弯曲程度，cubic、horizontal、cubic-vertical、cubic-horizontal 等贝塞尔曲线特有
          // curveOffset: -50,



          // 内置边 cubic 特有属性
          // controlPoints: [{ x: 500, y: 400 }, { x: 300, y: 0 }], // 不指定时将会使用默认的控制点：曲线 1/3 和 2/3 处，二阶贝塞尔曲线 需要 2 个控制点
          // curvePosition: [0.4, 0.9], // 优先级低于 controlPoints，控制点的位置比例
          // curveOffset: [-90, 90], // 优先级低于 controlPoints，和 curvePosition 组合使用
          // minCurveOffset: [-30, 30], // 优化 curveOffset ,设置了一个最小值



          // 内置类型 arc 圆弧特有属性
          // curveOffset: 40, // 圆弧顶端距离两线中心位置的距离


          // 内置 loop 边特有属性（loop 边适用于自环边，即起始点与结束点为相同节点的边，在不同端点的边上适用 loop 边将会出现异常效果。）
          // style: {
          //   endArrow: true,
          // },
          // loopCfg: {
          //   position: 'top', // top, top-right, right,bottom-right, bottom, bottom-left, left, top-left
          //   dist: 100, // 从节点 keyShape 的边缘到自环最顶端的位置，用于指定自环的曲度，默认为节点的高度。
          //   clockwise: true, // 指定是否顺时针画环，默认为  true。
          //   pointPadding: 15, // 对于非圆形节点设置的连接点与节点中心坐标，在 x 轴或 y 轴方向的偏移量，默认为  节点宽高中最小值的1/4，也可以是数组4个值
          // }
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: 600,
      height: 600,
    });

    graph.data(data);
    graph.render();
  },
};
</script>

{% endraw %}
``` 




### 箭头的配置
![g6_04](/static/img/g6/g6_04.jpg)

```vue
{% raw %}
<template>
  <div ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 120, // 节点的大小
          type: 'circle',
          label: '起始点',
          labelCfg: {
            style: {
              name: 'n1',
              fill: '#fff',
              stroke: 'black',
              fontSize: 30,
            }
          },
          style: {
              name: 'n1',
              fill: 'orangered',
              stroke: 'violet'
          }
        },
        {
          id: 'node2',
          x: 500,
          y: 200,
          size: 60,
          size: 120,
          label: '目标点',
          labelCfg: {
            style: {
              fontSize: 24
            }
          }
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线',
          style: {
            // 通用属性
            name: 'l1-2',
            stroke: 'violet',
            lineWidth: 10,
            endArrow: true,
            startArrow: {
              // 类型：triangle/vee/circle/diamond/rect/triangleRect  
              path: G6.Arrow.triangle(40, 40, 10), // 参数依次为 宽、长、偏移量
              d: 20, // 箭头的偏移量（一般情况下与 G6.Arrow 的方法的偏移量保持一致即可）
              fill: 'red',
              stroke: 'blue',
              lineWidth: 2, // 描边宽度
              lineDash: [2, 2], // 描边的虚线
              opacity: 1,
              shadowColor: 'red',
              shadowColorBlur: 2,
              shadowOffsetX: 1,
              shadowOffsetY: 1
            }
          },
          labelCfg: {
            refX: 20,
            refY: 20,
            autoRotate: true,
            style: {
              fontSize: 18
            }
          }
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: 600,
      height: 600,
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```
> 每个类型的具体参数[文档](https://g6-v4.antv.vision/manual/middle/elements/edges/arrow)。






### Combo 节点分组
Combo 节点分组是非常实用的一个功能，通过定义不同的 Combo 将点拖动到不同标注区域的 Combo 内进行分组归类分析。

![g6_05](/static/img/g6/g6_05.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 60, // 节点的大小
          type: 'circle',
          label: '起始点',
          labelCfg: {
            style: {
              name: 'n1',
              fill: '#fff',
              stroke: 'black',
              fontSize: 16,
            }
          },
          style: {
              name: 'n1',
              fill: 'orangered',
              stroke: 'violet'
          }
        },
        {
          id: 'node2',
          x: 500,
          y: 200,
          size: 80,
          label: '目标点',
          labelCfg: {
            style: {
              fontSize: 18
            }
          }
        }
      ],
      combos: [ // combo 集合
        {
          id: 'combo1',
          type: 'circle', // circle/rect
          label: '节点分组1',
          labelCfg: {
            position: 'center',
            refX: 10,
            refY: 10,
            style: {
              fill: 'blue',
              fontSize: 16
            }
          },
          // parentId: 'combo0' // 当前 combo 的父 combo
          size: 100, // 最小尺寸，原型就是圆心，矩形设置宽高为数组
          padding: 40,
          // fixSize: 300, // 固定尺寸，不固定时有内部元素决定，若指定了 fixSize 而没有指定 fixCollapseSize，则即使该 Combo 在收起状态下仍然保持 fixSize 指定的尺寸
          fixCollapseSize: 100, // 固定 combo 收起时的尺寸，未指定 fixSize 时由 size 决定，否则就是 fixSize
          collapsed: false, // 折叠状态
          collapsedSubstituteIcon: { // 折叠状态展示的图片
            show: true,
            img: '/image/logo.png',
            width: 50,
            height: 50
          },
          style: {
            fill: 'gainsboro'
          },
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线',
          style: {
            // 通用属性
            name: 'l1-2',
            stroke: 'violet',
            lineWidth: 4
          },
          labelCfg: {
            refX: 20,
            refY: 20,
            autoRotate: true,
            style: {
              fontSize: 18
            }
          }
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理
      groupByTypes: false,
      modes: {
        default: [
          'drag-combo', // 允许拖动 combo
          'drag-node', // 允许拖动 节点
          'collapse-expand-combo', // 双击 折叠/展开 combo
        ]
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```
> + 节点分组 [demo](https://g6-v4.antv.vision/zh/examples/net/comboLayout#comboCombined)
+ **<font color=red>若图配置有布局且该 behavior 的 relayout 配置项为 true（默认为 true），则该 behavior 被触发后会触发图的重新布局。若希望避免重新布局，可以配置 relayout 为 false ，或通过监听 combo 点击事件和 graph.collapseExpandCombo API 控制收缩展开逻辑。</font>**




### 聚类轮廓包裹
![g6_02](/static/img/g6/g6_02.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%; height: 100%" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo4",
  mounted() {
    const data = {
      nodes: [
        // 点集合
        {
          id: "node1",
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 60, // 节点的大小
          type: "circle",
          label: "起始点",
          labelCfg: {
            style: {
              fill: "#fff",
              stroke: "black",
              fontSize: 16,
            },
          },
          style: {
            fill: "orangered",
            stroke: "violet",
          },
        },
        {
          id: "node2",
          x: 300, // 坐标点
          y: 200, // 坐标点
          size: 60, // 节点的大小
          type: "circle",
          label: "中间点",
          labelCfg: {
            style: {
              fill: "#fff",
              stroke: "black",
              fontSize: 16,
            },
          },
          style: {
            fill: "orangered",
            stroke: "violet",
          },
        },
        {
          id: "node3",
          x: 500, // 坐标点
          y: 200, // 坐标点
          size: 60, // 节点的大小
          type: "circle",
          label: "结束点",
          labelCfg: {
            style: {
              fill: "#fff",
              stroke: "black",
              fontSize: 16,
            },
          },
          style: {
            fill: "orangered",
            stroke: "violet",
          },
        },
      ],
      edges: [
        // 边集合
        {
          id: "1-2",
          source: "node1",
          target: "node2",
          label: "我是连线",
          style: {
            stroke: "violet",
            lineWidth: 4,
          },
          labelCfg: {
            refY: 20,
            autoRotate: true,
            style: {
              fontSize: 18,
            },
          },
        },
        {
          id: "2-3",
          source: "node2",
          target: "node3",
          label: "我是连线",
          style: {
            stroke: "violet",
            lineWidth: 4,
          },
          labelCfg: {
            refY: 20,
            autoRotate: true,
            style: {
              fontSize: 18,
            },
          },
        },
      ],
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
    });

    let h1;

    graph.on('afterrender', () => {
      h1 = graph.createHull({
        id: 'h-1',
        /**
         * 类型：round-convex 圆角凸包轮廓 / smooth-convex 平滑凸包轮廓 / bubble 平滑凹包轮廓
         * */
        type: 'round-convex',
        members: ['node1', 'node2'],
        // nonMembers: ['node2'], // 仅针对 bubble 类型有效（目前不清楚何种场景生效）
        padding: 10,
        style: {
          fill: 'lightgreen',
          stroke: 'green',
        }
      });
    });

    // 手动更新聚类的节点结合
    setTimeout(() => {
      console.log(graph.getHulls()); // 获取所有轮廓 map
      h1.updateData(['node2', 'node3']);
    }, 3000);

    setTimeout(() => {
      graph.removeHull('h-1'); // 移除指定的 id 的轮廓
      // graph.removeHulls();
    }, 5000);

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```


### 布局的配置
#### 默认布局
![g6_07](/static/img/g6/g6_07.jpg)
实例化不配置 ``layout`` 时采用默认布局，数据中存在  ``x`` 和 ``y`` 属性时，就按照数据位置信息绘制，如果没有就按照 ``Random Layout`` 进行布局。

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 300,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        type: 'circle',
        size: 80,
        labelCfg: {
          style: {
            fill: '#fff',
            stroke: 'black',
            fontSize: 16,
          }
        },
        style: {
            fill: 'orangered',
            stroke: 'violet'
        }
      },
      defaultEdge: {
        style: {
          stroke: 'violet',
          lineWidth: 4
        },
        labelCfg: {
          refX: 20,
          refY: 20,
          autoRotate: true,
          style: {
            fontSize: 18
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```




#### 随机布局
![g6_06](/static/img/g6/g6_06.jpg)
节点没有 ``x`` 和 ``y`` 配置，随机布局的算法决定节点位置。

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          label: '起始点'
        },
        {
          id: 'node2',
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      fitCenter: true,
      layout: { // 布局配置对象
        type: 'random', // 随机布局
        center: [0, 0],
        width: 800, // 布局宽
        height: 600, // 布局高
        workerEnabled: true // 是否启用 web-worker 以防布局计算时间过长阻塞页面交互
      },
      defaultNode: {
        type: 'circle',
        size: 80,
        labelCfg: {
          style: {
            fill: '#fff',
            stroke: 'black',
            fontSize: 16,
          }
        },
        style: {
            fill: 'orangered',
            stroke: 'violet'
        }
      },
      defaultEdge: {
        style: {
          stroke: 'violet',
          lineWidth: 4
        },
        labelCfg: {
          refX: 20,
          refY: 20,
          autoRotate: true,
          style: {
            fontSize: 18
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```

#### 层次布局(流程图)
自由度高，节点之间配置连线即可， ``G6.TreeGraph`` 树图由于数据结构是树形的没法反向连线（[流程图配置项](https://g6-v4.antv.vision/api/graph-layout/dagre)）。

**<font color=red>注：建议看完</font>** [自定义节点](#自定义节点) **<font color=red>和</font>** [自定义边](#自定义边) **<font color=red>后再看此布局，此 demo 使用了自定义边和自定义节点。</font>**

![g6_01](/static/img/g6/g6_01.jpg)

``data.js``
```javascript
export default {
  nodes: [
    { id: '1', title: '1', description: '1-xxx' },
    { id: '2', title: '2', description: '2-xxx' }, { id: '3', title: '3', description: '3-xxx' },
    { id: '4', title: '4', description: '4-xxx' },
    { id: '5', title: '5', description: '5-xxx' },
    
  ],
  edges: [
    { source: '1', target: '2', label: '1-2' },
    { source: '1', target: '3', label: '1-3' },
    { source: '2', target: '4', label: '2-4' },
    { source: '3', target: '4', label: '3-4' },
    { source: '4', target: '5', label: '4-5' },
  ]
};
```

``dagre.vue``
```vue
{% raw %}
<template>
  <div ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";
import dagreData from "./data.js";

export default {
  name: "demo",
  created() {
    // 自定义节点
    G6.registerNode("card-node", {
      draw: function drawShape(cfg, group) {
        const r = 2;
        const color = "#5B8FF9";
        // cfg 为 defaultNode 配置项配的引用 & 节点数据项的引用
        const w = cfg.size[0];
        const h = cfg.size[1];
        // addShap 方法的结果要作为方法的返回值使用
        const shape = group.addShape("rect", {
          name: "整体背景色块",
          attrs: {
            x: -w / 2,
            y: -h / 2,
            width: w,
            height: h,
            stroke: color,
            radius: r,
            fill: "#fff"
          }
        });
        group.addShape("rect", {
          name: "标题背景色块",
          attrs: {
            x: -w / 2,
            y: -h / 2,
            width: w,
            height: h / 2,
            fill: color,
            radius: [r, r, 0, 0]
          }
        });
        group.addShape("text", {
          name: "标题文本",
          attrs: {
            textBaseline: "top",
            x: -w / 2 + 8,
            y: -h / 2 + 2,
            lineHeight: 20,
            text: cfg.title,
            fill: "#fff"
          }
        });
        group.addShape("text", {
          name: "描述文本",
          attrs: {
            textBaseline: "top",
            x: -w / 2 + 8,
            y: -h / 2 + 24,
            lineHeight: 20,
            text: cfg.description,
            fill: "rgba(0,0,0, 1)",
          }
        });

        return shape;
      }
    });

    // 自定义边
    G6.registerEdge("card-edge", {
      labelAutoRotate: true,
      draw(cfg, group) {
        const startPoint = cfg.startPoint;
        const endPoint = cfg.endPoint;
        // cfg 为 defaultEdge 配置项配的引用 & 边线数据项的引用
        const stroke = (cfg.style && cfg.style.stroke) || this.options.style.stroke;
        const shape = group.addShape("path", {
          name: "边线",
          attrs: {
            stroke,
            path: [
              ["M", startPoint.x, startPoint.y],
              ["L", endPoint.x, endPoint.y],
            ],
          }
        });
        
        // 边线文字
        group.addShape("text", {
          name: "边线文字",
          attrs: {
            text: cfg.label,
            fill: "#595959",
            textAlign: "center",
            textBaseline: "middle",
            x: startPoint.x + (endPoint.x - startPoint.x) / 2,
            y: startPoint.y + (endPoint.y - startPoint.y) / 2
          }
        });

        return shape;
      },
    });
  },
  mounted() {
    const dagre = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: 1840,
      height: 600,
      modes: {
        default: [
          "drag-canvas", // 拖动画布
          "zoom-canvas", // 缩放画布
        ],
      },
      layout: {
        type: "dagre", // 流程图
        // begin: [0, 0], // 布局的左上角对齐位置
        rankdir: "TB", // 布局顺序 'TB' | 'BT' | 'LR' | 'RL'
        align: undefined, // 对齐方式 'UL' | 'UR' | 'DL' | 'DR' | undefined（默认为 undefined，对称布局）
        nodesep: 50, // 节点的水平或垂直（根据布局顺序而定）间距
        // nodesepFunc: function (n) {}, // nodesep 的回调函数
        ranksep: 10, // 层间距
        // ranksepFunc: function (n) {}, // ranksep 的回调函数
        controlPoints: false, // 是否保留布局连线的控制点
        workerEnabled: false, //  是否启用 web-worker 以防布局计算时间过长阻塞页面交互。 ⚠️ 注意: workerEnabled: true 时，不支持所有函数类型的参数。
        sortByCombo: false, // 同一层节点是否根据每个节点数据中的 comboId 进行排序，以防止 combo 重叠
        nodeOrder: undefined, // 同层节点顺序的参考数组，存放节点 id 值。若未指定，则将按照 dagre 本身机制排列同层节点顺序。
      },
      defaultNode: {
        type: "card-node", // 自定义节点类型（通过 G6.registerNode('card-node', {...})）进行注册（默认节点无需声明此属性）
        size: [80, 50], // 节点大小
        style: {
          stroke: '#c2c8d5'
        },
        anchorPoints: [
          // 节点的连线位置（可以设置多个，0、0.5、1 百分比浮点数，分别表示左、中、右，数组第一个之水平位置第二个之垂直位置）
          [0.5, 0], // 上边界中心点
          [0.5, 1], // 下边界中心点
        ],
      },
      defaultEdge: {
        type: "card-edge", // 自定义边类型（通过 G6.registerEdge('card-edge', {...})）进行注册（默认节点无需声明此属性）
        // lineDash: [2, 2], // 虚线的间距和长度
        style: {
          // 线的样式
          stroke: 'orange'
        },
        labelCfg: {
          // 文字的样式
        },
      },
    });

    dagre.data(dagreData);
    dagre.render();

    // 节点定制化 - 根据条件设置节点的边距或者使用不同的自定义节点类型
    // dagre.node((node) => {
    //   return {};
    // });

    // 边定制化 - 根据条件设置边线的样式或者使用不同的自定义边线类型
    // darge.edge((edge) => {
    //   return {};
    // });

    // 事件绑定 - 画布渲染后触发
    // darge.on("afterrender", () => {
    //   darge.changeSize(500, 500) // 再次改变画布大小
    // });

    // 事件绑定 - 节点点击事件
    // darge.on("node-click", () => {});

    // 事件绑定 - 边点击事件
    // darge.on("edge-click", () => {});

    // api
    // fitView - 图形适应画布大小
    // moveTo - 移动图形到指定坐标
    // changeSize - 改变画布大小
    // getCanvasBBox - 获取图形大小
    // data - 设置数据
    // render - 渲染

    // 技巧
    // 隐藏节点 - 给节点配置 display: false 属性。
    // 隐藏边 - 通过边的定制化设置透明度。
  },
};
</script>

<style lang="less" scoped>
#container {
  height: 100%;
  width: 100%;
}
</style>
{% endraw %}
```
> 流程图 - 自由度高，节点之间配置连线即可，G6.TreeGraph 树图由于数据结构是树形的没法反向连线。


## 状态
![g6_08](/static/img/g6/g6_08.gif)




### 配置时机

**1\. 实例化配置对象配置  ``nodeStateStyles`` 和 ``edgeStateStyles`` 配置。**
```javascript
{% raw %}
const graph = new G6.Graph({
  // 略...
  nodeStateStyles: {
    hover: { // 状态名称
      fill: 'orange'
    }
  },
  edgeStateStyles: {
    hover: { // 状态名称
      fill: 'orange'
    }
  }
  // 略...
});
{% endraw %}
```

**2\. 节点/边数据中定义 ``state`` 样式。**
```javascript
{% raw %}
const data = {
  nodes: [ // 点集合
    {
      id: 'node1',
      x: 100, // 坐标点
      y: 200, // 坐标点
      label: '起始点',
      stateStyles: {
        hover: {
          fill: 'orange'
        }  
      }
    },
    {
      id: 'node2',
      x: 300,
      y: 200,
      label: '结束点',
      stateStyles: {
        hover: {
          fill: 'orange'
        }  
      }
    }
  ],
  edges: [ // 边集合
    {
      id: '1-2',
      source: 'node1',
      target: 'node2',
      label: '我是连线',
      stateStyles: {
        hover: {
          fill: 'orange'
        }  
      }
    }
  ]
};
{% endraw %}
```

**3\. 自定义节点和边时定义 ``state`` 样式。**

见[自定义节点](#自定义节点)、[自定义边](#自定义边)内容。



### 调用时机

**1\. graph.on 的回调函数。**
```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  name: "demo1",
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 300,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        type: 'circle',
        size: 80,
        labelCfg: {
          style: {
            fill: '#fff',
            fontSize: 16,
          }
        },
        style: {
          fill: 'orangered',
          stroke: 'violet'
        }
      },
      defaultEdge: {
        style: {
          stroke: 'violet',
          lineWidth: 4
        },
        labelCfg: {
          refX: 20,
          refY: 20,
          autoRotate: true,
          style: {
            fontSize: 18
          }
        }
      },
      nodeStateStyles: { // 节点状态
        hover: { // 状态名称
          fill: 'orange',
          'node-text': { // 配置该节点下 name 为 node-text 的图形的样式（应该是给自定义边/节点使用的）
            fill: 'blue',
            fontSize: 24
          }
        },
        'apple:red': { // 多值状态，类似命名空间
          fill: 'red'
        },
        'apple:blue': { // 多值状态，类似命名空间
          fill: 'blue'
        }
      },
      edgeStateStyles: { // 边状态
        hover: {
          fill: 'blue'
        }
      }
    });

    // 监听事件更改状态
    graph.on('node:mouseenter', (evt) => {
      const { item } = evt;

      // setItemState 第一个入参为 节点实例 或者 节点的 id。
      graph.setItemState(item, 'hover', true);
      // 多值状态
      // graph.setItemState(item, 'apple', 'red');
    });

    graph.on('node:mouseleave', (evt) => {
      const { item } = evt;
      graph.setItemState(item, 'hover', false);
      // 多值状态
      // graph.setItemState(item, 'apple', 'blue');
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```



**2. 自定义的 ``Behavior`` 中使定义的交互状态 ``selected`` 生效。**


### 重写 & 取消
通过 ``graph.updateItem`` 方法进行状态重写操作（如果重写的节点已经处在某种状态，重写时会直接体现出来）；通过 ``graph.clearItemStates`` 方法进行状态取消操作（支持单个或者多个状态取消）。

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 300,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        type: 'circle',
        size: 80,
        labelCfg: {
          style: {
            fill: '#fff',
            stroke: 'black',
            fontSize: 16,
          }
        },
        style: {
            fill: 'orangered',
            stroke: 'violet'
        }
      },
      defaultEdge: {
        style: {
          stroke: 'violet',
          lineWidth: 4
        },
        labelCfg: {
          refX: 20,
          refY: 20,
          autoRotate: true,
          style: {
            fontSize: 18
          }
        }
      },
      nodeStateStyles: { // 节点状态
        hover: { // 状态名称
          fill: 'orange'
        },
        'apple:red': { // 多值状态，类似命名空间
          fill: 'red'
        },
        'apple:blue': { // 多值状态，类似命名空间
          fill: 'blue'
        }
      },
      edgeStateStyles: { // 边状态
        hover: {
          fill: 'blue'
        }
      }
    });

    graph.data(data);
    graph.render();

    setTimeout(() => {
      graph.setItemState('node1', 'hover', true);
    }, 1000);

    setTimeout(() => {
      graph.updateItem('node1', {
        stateStyles: {
          hover: {
            fill: 'black'
          }
        }
      })
    }, 2000);

    setTimeout(() => {
      graph.clearItemStates('node1', 'hover');
    }, 3000);
  },
};
</script>
{% endraw %}
```



### 状态注意事项
1. 样式优先级原则：后设置的状态 > 先设置的。
> + 通过 ``hasState`` 方法判断元素状态是否激活。






## 进阶
### 自定义节点
[官网文档](https://g6-v4.antv.vision/manual/middle/elements/nodes/custom-node)

``G6`` 提供了一系列内置节点，包括 ``circle、rect、diamond、triangle、star、image、modelRect`` 。若内置节点无法满足需求，用户还可以通过 ``G6.registerNode(typeName: string, nodeDefinition: object, extendedNodeType?: string)`` 进行自定义节点，方便用户开发更加定制化的节点。

**自定义节点的 API 如下：**
```javascript
G6.registerNode(
  'nodeName',
  {
    options: {
      style: {},
      stateStyles: {
        hover: {},
        selected: {},
      },
    },
    /**
     * 绘制节点，包含文本
     * @param  {Object} cfg 节点的配置项
     * @param  {G.Group} group 图形分组，节点中图形对象的容器
     * @return {G.Shape} 返回一个绘制的图形作为 keyShape，通过 node.get('keyShape') 可以获取。
     * 关于 keyShape 可参考文档 核心概念-节点/边/Combo-图形 Shape 与 keyShape
     */
    draw(cfg, group) {},
    /**
     * 绘制后的附加操作，默认没有任何操作
     * @param  {Object} cfg 节点的配置项
     * @param  {G.Group} group 图形分组，节点中图形对象的容器
     */
    afterDraw(cfg, group) {},
    /**
     * 更新节点，包含文本
     * @override
     * @param  {Object} cfg 节点的配置项
     * @param  {Node} node 节点
     */
    update(cfg, node) {},
    /**
     * 更新节点后的操作，一般同 afterDraw 配合使用
     * @override
     * @param  {Object} cfg 节点的配置项
     * @param  {Node} node 节点
     */
    afterUpdate(cfg, node) {},
    /**
     * 响应节点的状态变化。
     * 在需要使用动画来响应状态变化时需要被复写，其他样式的响应参见下文提及的 [配置状态样式] 文档
     * @param  {String} name 状态名称
     * @param  {Object} value 状态值
     * @param  {Node} node 节点
     */
    setState(name, value, node) {},
    /**
     * 获取锚点（相关边的连入点）
     * @param  {Object} cfg 节点的配置项
     * @return {Array|null} 锚点（相关边的连入点）的数组,如果为 null，则没有控制点
     */
    getAnchorPoints(cfg) {},
  },
  // 继承内置节点类型的名字，例如基类 'single-node'，或 'circle', 'rect' 等
  // 当不指定该参数则代表不继承任何内置节点类型
  extendedNodeType,
);
```

**自定义节点的定义 demo 如下：**

![g6_03](/static/img/g6/g6_09.gif)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义方块节点
    G6.registerNode('custom-rect', {
      draw(cfg, group) {
        const keyShap = group.addShape('rect', {
          name: '大方块',
          attrs: {
            width: 60,
            height: 40,
            x: 0,
            y: 0,
            fill: 'red',
            stroke: 'blue'
          }
        });

        group.addShape('rect', {
          name: '小方块',
          attrs: {
            width: 40,
            height: 20,
            x: 10,
            y: 10,
            fill: 'orange',
            stroke: 'black'
          }
        });


        return keyShap;
      },
      /**
       * 1. 当图中节点或边通过  graph.update(item, cfg) 重绘时，默认情况下会调用节点的 draw 方法进行重新绘制。
       * 在数据量大或节点上图形数量非常多（特别是文本多）的情况下，draw 方法中对所有图形、赋予样式将会非常消耗性能。
       * 2. 在自定义节点时，重写  update 方法，在更新时将会调用该方法替代 draw。
       * 我们可以在该方法中指定需要更新的图形，从而避免频繁调用  draw 、全量更新节点上的所有图形。
       * 3. update 方法是可选的，如果没有性能优化的需求可以不重写该方法。
       * 
       **/
      update(cfg, node) {
        const group = node.getContainer(); // 获取引用组
        const bigRect = group.get('children')[0]; // 按照添加的顺序获取
        // const smallRect = group.get('children')[1]; // 按照添加的顺序获取

        // 更新通过 graph.update(item, cfg) 方法节点时读取传递的参数进行更新
        bigRect.attr({ fill: cfg.fill });
      },
      /**
       *指定锚点：锚点可以指定多个，每个数组项为连接点第一项为 x 第二项为 y，0/0.5/1 三个值 
       **/
      getAnchorPoints() {
        return [
          [0, 0.5], // 左中
          [1, 0.5] // 右中
        ]
      },
      /**
       *设置状态更新，简易使用此方法，不建议通过 options 里 stateStyles 对象配置
       **/
      setState(name, value, node) {
        const group = node.getContainer(); // 获取引用组
        const bigRect = group.get('children')[0]; // 按照添加的顺序获取

        if (name === 'hover') {
          if (value) {
            bigRect.attr('fill', 'gainsboro');
          } else {
            bigRect.attr('fill', 'orange');
          }
        }
      }
    });

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 80,
          label: '起始点',
          labelCfg: {
            style: {
              fontSize: 18,
              fill: '#fff'
            }
          },
          style: {
            fill: 'blue'
          }
        },
        {
          id: 'node2',
          type: 'custom-rect',
          x: 300,
          y: 200,
          label: '中间点'
        },
        {
          id: 'node3',
          type: 'custom-rect',
          x: 500,
          y: 200,
          label: '结束点'
        },
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        },
        {
          id: '2-3',
          source: 'node2',
          target: 'node3',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
    });

    // 悬停时，更改自定义节点的状态，调用 注册方法里面的 setState 方法处理
    graph.on('node:mouseenter', e => {
      const node = e.item;

      graph.setItemState(node, 'hover',  !node.hasState('hover'));
    });
    graph.data(data);
    graph.render();

    setTimeout(() => {
      // 更新自定义节点 custom-rect 样式，由于有定义 update 方法，会走该方法更新
      graph.update('node2', { fill: 'pink' });
    }, 2000);
  },
};
</script>
{% endraw %}
```

**使用 DOM 自定义节点，如下：**

![g6_10](/static/img/g6/g6_10.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义方块节点
    G6.registerNode('custom-dom-rect', {
      draw(cfg, group) {
        return group.addShape('dom', {
          attrs: {
            width: cfg.size,
            height: cfg.size,
            // 传入 DOM 的 html
            html: `<div style="width: 60px;height: 40px;background-color: orange">自定义节点</div>`,
          },
          // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
          name: 'dom-node-keyShape'
        });
      },
      /**
       *指定锚点：锚点可以指定多个，每个数组项为连接点第一项为 x 第二项为 y，0/0.5/1 三个值 
       **/
      getAnchorPoints() {
        return [
          [0, 0.5], // 左中
          [1, 0.5] // 右中
        ]
      }
    });

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          size: 80,
          label: '起始点',
          labelCfg: {
            style: {
              fontSize: 18,
              fill: '#fff'
            }
          },
          style: {
            fill: 'blue'
          }
        },
        {
          id: 'node2',
          type: 'custom-dom-rect',
          x: 300,
          y: 200,
          size: 80,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      renderer: 'svg',
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```
> + 仅在 ``Graph`` 的 ``renderer`` 为  ``'svg'`` 时可以使用。
+ 使用 'dom' 进行自定义的节点或边，不支持 G6 的交互事件，请使用原生 DOM 的交互事件。
+ 在 ``Safari`` 中，若 ``dom`` 节点被设置了 ``position:relative`` 将会导致渲染异常。[Issue](https://github.com/antvis/G6/issues/2990)。


### 自定义边
[官网文档](https://g6-v4.antv.vision/manual/middle/elements/edges/custom-edge)

**自定义边的 API 如下：**

```vue
{% raw %}
<script>
G6.registerEdge(
  'edgeName',
  {
    /**
     * 绘制边，包含文本
     * @param  {Object} cfg 边的配置项
     * @param  {G.Group} group 图形分组，边中的图形对象的容器
     * @return {G.Shape} 绘制的图形，通过 node.get('keyShape') 可以获取到
     */
    draw(cfg, group) {},
    /**
     * 绘制后的附加操作，默认没有任何操作
     * @param  {Object} cfg 边的配置项
     * @param  {G.Group} group 图形分组，边中的图形对象的容器
     */
    afterDraw(cfg, group) {},
    /**
     * 更新边，包含文本
     * @override
     * @param  {Object} cfg 边的配置项
     * @param  {Edge} edge 边
     */
    update(cfg, edge) {},
    /**
     * 更新边后的操作，一般同 afterDraw 配合使用
     * @override
     * @param  {Object} cfg 边的配置项
     * @param  {Edge} edge 边
     */
    afterUpdate(cfg, edge) {},
    /**
     * 设置边的状态，主要是交互状态，业务状态请在 draw 方法中实现
     * 单图形的边仅考虑 selected、active 状态，有其他状态需求的用户自己复写这个方法
     * @param  {String} name 状态名称
     * @param  {Object} value 状态值
     * @param  {Edge} edge 边
     */
    setState(name, value, edge) {},
  },
  'extendedEdgeName',
);
</script>
{% endraw %}
```




**直接使用 Path 生成边路径，如下：**

![g6_10](/static/img/g6/g6_11.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义方块节点
    G6.registerEdge('custom-edge', {
      draw(cfg, group) {
        const {
          startPoint: {
            x: sx,
            y: sy
          },
          endPoint: {
            x: ex,
            y: ey
          }
        } = cfg;

        return group.addShape('path', {
          attrs: {
            stroke: 'orange',
            // 使用路径画一个直角边
            path: [
              ['M', sx, sy], // 起点 M 是 svg 矢量图里面常用的命令，表示把画笔移动(Move)到某个坐标上
              ['L', sx + (ex - sx) / 2, sy + (ex - sx) / 2], // 划线，L 是 svg 矢量图里面常用的命令，表示画一条直线(Line)到某个坐标上停止
              ['L', ex, ey]
            ]
          },
          // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
          name: 'custom-edge-keyShape'
        });
      }
    });

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 400,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          type: 'custom-edge',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        size: 80,
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'blue'
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```




**增加图形 & 文字，如下：**

![g6_12](/static/img/g6/g6_12.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义方块节点
    G6.registerEdge('custom-edge-square-text', {
      draw(cfg, group) {
        const {
          startPoint: {
            x: sx,
            y: sy
          },
          endPoint: {
            x: ex,
            y: ey
          }
        } = cfg;
        const width = 60;
        const height = 30;

        const keyShape = group.addShape('path', {
          attrs: {
            stroke: 'orange',
            path: [
              ['M', sx, sy],
              ['L', ex, ey]
            ]
          },
          // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
          name: 'custom-edge-path'
        });

        // 添加方块
        group.addShape('rect', {
          attrs: {
            stroke: 'green',
            lineWidth: 4,
            width,
            height,
            fill: 'orangered',
            x: sx + (ex - sx) / 2 - width / 2,
            y: sy + (ey - sy) / 2 - height / 2
          },
          // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
          name: 'custom-edge-square'
        });

        const fontSize = 12;

        // 添加文字
        group.addShape('text', {
          attrs: {
            text: cfg.label,
            fill: '#fff',
            fontSize,
            textAlign: 'center',
            x: sx + (ex - sx) / 2, // x 和 y 以添加的第一个图形为准
            y: sy + (ey - sy) / 2 + fontSize / 2
          },
          // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
          name: 'custom-edge-text'
        });

        return keyShape;
      }
    });

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 400,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          type: 'custom-edge-square-text',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        size: 80,
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'blue'
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```





**通过第三个入参设置为已有边类型跳过边的绘制，再通过 afterDraw 回调函数添加 图形 和 文字，如下：**

![g6_13](/static/img/g6/g6_13.jpg)

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义方块节点
    G6.registerEdge('custom-edge-square-text',
      {
        afterDraw(cfg, group) {
          // 获取图形组中的第一个图形，在这里就是边的路径图形
          const shape = group.get('children')[0];
          // 获取路径图形的中点坐标
          const { x, y } = shape.getPoint(0.5);

          // 添加方块
          const width = 80;
          const height = 30;

          group.addShape('rect', {
            attrs: {
              width: 80,
              height: 30,
              lineWidth: 4,
              x: x - width / 2,
              y: y - height / 2,
              stroke: 'green',
              fill: 'orangered'
            },
            // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
            name: 'custom-edge-square'
          });

          const fontSize = 12;

          // 添加文字
          group.addShape('text', {
            attrs: {
              text: cfg.label,
              fill: '#fff',
              fontSize,
              textAlign: 'center',
              x, // x 和 y 以添加的第一个图形为准
              y: y + fontSize / 2
            },
            // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性
            name: 'custom-edge-text'
          });
        },
        update: undefined
      },
      'cubic' // 通过继承已有的 边，跳过 draw 方法
    );

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 400,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          type: 'custom-edge-square-text',
          label: '我是连线',
          style: {
            lineWidth: 4,
            stroke: 'violet'
          }
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        size: 80,
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'blue'
          }
        }
      }
    });

    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```
> + 通过配置 ``G6.registerEdge`` 第三个参数来继承已有的内置边，只在 ``afterDraw`` 中添加额外内容。





**边的交互 & 自定义箭头**

**<font color=red>注：3.4.1 版本之后，箭头的指向有 x 轴的正方向改为了 x 轴的负方向。</font>**

![g6_14](/static/img/g6/g6_14.jpg)

![g6_15](/static/img/g6/g6_15.gif)

右箭头的颜色变化是单独设置的。

```vue
{% raw %}
<template>
  <div style="width: 100%;height: 100%;" ref="container" id="container"></div>
</template>

<script>
import G6 from "@antv/g6";

export default {
  mounted() {
    // 注册自定义边
    G6.registerEdge('custom-edge-arrow',
      {
        draw(cfg, group) {
          const {
            startPoint: {
              x: sx,
              y: sy
            },
            endPoint: {
              x: ex,
              y: ey
            }
          } = cfg;

          return group.addShape('path', {
            attrs: {
              path: [
                ['M', sx, sy],
                ['L', ex, ey] // 结束连线保留 20 的空白间距
              ],
              stroke: 'red',
              lineWidth: 4,
              startArrow: {
                path: 'M 0,0 L 20,10 L 20,-10 Z', // svg 语法 Z 表示闭合路径
                fill: 'blue'
              },
              endArrow: {
                path: 'M 40,0 L 60,10 L 60,-10 Z', // svg 语法 Z 表示闭合路径
                fill: 'green',
                lineWidth: 2,
                stroke: 'orange',
                d: 20 // 保留 20 的留白，需要把 调整 M 和 L
              }
            },
            name: 'custom-edge-path'
          });
        },
        setState(name, value, item) {
          const group = item.getContainer();
          const keyShape = group.get('children')[0];

          const attr = keyShape.attr(); // 获取配置项

          if (name === 'hover') {
            if (value) {
              keyShape.attr('stroke', 'black'); // 单个属性更新

              const endArrow = attr.endArrow;
              
              endArrow.stroke = 'red'; // 重写箭头样式
              keyShape.attr({ // 传入对象，批量更新
                stroke: 'black',
                endArrow: {
                  ...endArrow // 一定要进行深克隆，否则无效
                }
              });
            } else {
              keyShape.attr('stroke', 'red');
            }
          }
        }
      }
    );

    const data = {
      nodes: [ // 点集合
        {
          id: 'node1',
          x: 100, // 坐标点
          y: 200, // 坐标点
          label: '起始点'
        },
        {
          id: 'node2',
          x: 400,
          y: 200,
          label: '结束点'
        }
      ],
      edges: [ // 边集合
        {
          id: '1-2',
          source: 'node1',
          target: 'node2',
          type: 'custom-edge-arrow',
          label: '我是连线'
        }
      ]
    };

    const graph = new G6.Graph({
      container: this.$refs.container, // id 或者 dom 元素
      width: parseInt(this.$refs.container.clientWidth),
      height: parseInt(this.$refs.container.clientHeight),
      defaultNode: {
        size: 80,
        labelCfg: {
          style: {
            fontSize: 18,
            fill: 'blue'
          }
        }
      }
    });

    graph.on('edge:mouseenter', e => {
      const item = e.item;

      graph.setItemState(item, 'hover', !item.hasState('hover'));
    });
    graph.data(data);
    graph.render();
  },
};
</script>
{% endraw %}
```
> **<font color=red>使用 keyShape.attr 方法通过传入对象进行批量更新的时候如果要复用之前的配置，需要进行深克隆后传递。</font>**。



## api
### getCanvasBBox

| 用途 | 注意事项 |
| :--- | :--- |
| 获取画布中元素的整体宽和高（e.g. 画布中树形结构的图形的宽高） | [5 版本](https://github.com/antvis/G6/issues/5938)后方法改为 ``graph.getCanvas().getBounds('elements').halfExtents`` 数组第一项是元素的宽的一半，第二项是元素的高的一半 |