---
layout: post
title: Pinia
categories: [软件]
tags: [Vue, Pinia]
---

本章介绍 ``Pinia``，``Vue`` 项目的状态管理。

# pinia

+ [配置](#配置)
+ [数据定义方式](#数据定义方式)
    + [使用配置对象定义](#使用配置对象定义)
    + [使用函数定义](#使用函数定义)
+ [数据使用方式](#数据使用方式)
    + [基于选项 API 使用](#基于选项-api-使用)
    + [基于组合 API 使用](#基于组合-api-使用)
+ [进阶](#进阶)
    + [State](#state)



## 配置
文件 ``/src/main.js``。

```javascript
import { createApp } from 'vue';
import { createPinia } from 'pinia';
import App from './App.vue';

const pinia = createPinia();

createApp(App).use(pinia).mount('#app');
```

文件 ``/src/store/index.js``。

```javascript
import { defineStore } from 'pinia';

export const useCounterStore = defineStore('counter', {
    state: () => {
        return { count: 0 }
    },
    actions: {
        increment() {
            this.count++;
        }
    }
})
```

文件 ``/src/App.vue``。

```vue
<template>
    <div>{{ counter.count }}</div>
</template>

<script>
import { defineComponent, ref } from 'vue';
import { useCounterStore } from './store/index.js';

export default defineComponent({
    name: 'App',
    setup() {
        const counter = useCounterStore();

        counter.count++;

        return {
            counter
        };
    }
});
</script>
```




## 数据定义方式
### 使用配置对象定义

```javascript
import { defineStore } from 'pinia';

export const useCounterStore = defineStore('counter', {
    state: () => {
        return { count: 0 }
    },
    getters: {
        // 入参为 state
        double: (state) => state.count * 2
    },
    actions: {
        increment() {
            this.count++;
        }
    }
});
```


### 使用函数定义

```javascript
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export const useCounterStore = defineStore('counter', () => {
    // 选项 API 的 state
    let count = ref(1);

    // 选项 API 的 getters
    let double = computed(() => count.value * 2);

    // 选项 API 的 actions
    function increment() {
        count.value++;
    };

    return { count, double, increment };
});
```




## 数据使用方式
### 基于选项 API 使用

```vue
<template>
    <div>count:{{ count }}</div>
    <div>double:{{ double }}</div>
</template>

<script>
import { defineComponent, ref } from 'vue';
import { useCounterStore } from './store/index.js';
import { mapStores, mapState, mapActions } from 'pinia';

export default defineComponent({
    name: 'App',
    computed: {
        // 通过 this.counterStore 访问，useXxx(大写的 X 会转换为小写) 会转换为 this.xxx 进行访问
        ...mapStores(useCounterStore),

        // mapState 将 state 和 getters 一起扩展
        ...mapState(useCounterStore, ['count', 'double'])
    },
    methods: {
        ...mapActions(useCounterStore, ['increment'])
    },
    mounted() {
        setTimeout(() => {
            this.increment();
        }, 2000);
    }
});
</script>
```

> 访问形式和声明形式无关，使用组合 ``api`` 声明的依然可以用选项 ``api`` 上面这种方式访问。




### 基于组合 API 使用

```vue
<template>
    <div>counter.count:{{ counter.count }}</div>
    <div>counter.double:{{ counter.double }}</div>
</template>

<script>
import { defineComponent, ref } from 'vue';
import { useCounterStore } from './store/index.js';

export default defineComponent({
    name: 'App',
    setup() {
        const counter = useCounterStore();

        setTimeout(() => {
            counter.increment();
        }, 2000);

        return {
            counter
        };
    }
});
</script>
```

> 由于 ``store`` 是使用 ``reactive`` 包装的对象，所以不要解构属性，会失去响应式，同时所有定义的 ``state``、``getters``、``actions`` 都可以直接使用 .xxx 进行访问和调用。



## 进阶
### State

单个更新。

```javascript
store.count++;
```

批量更新方式一。

```javascript
store.$patch({
    count: store.count + 1,
    list: []
});
```


批量更新方式二。

```javascript
store.$patch((state) =>
    state.count++;
    state.list = [];
});
```

> + 入参是 ``state``。

监听 state 变动。

```vue
<template>
    <div>counterStore.count: {{ counterStore.count }}</div>
</template>

<script>
import { defineComponent, ref } from 'vue';
import { useCounterStore } from '../store/index.js';

export default defineComponent({
    name: 'cmTest',
    setup() {
        const counterStore = useCounterStore();

        counterStore.$subscribe((mutation, state) => {
            console.log('state', state);
        });

        setInterval(() => {
            counterStore.$patch((state) => {
                state.count++;
            });
        }, 2000);

        return {
            counterStore
        };
    }
});
</script>
```

> + 给 $subscribe 传入第二个配置对象入参 ``{ detached: true }`` 后，即便组件被卸载了，监听依然存，仍然会被触发，比如 A 组件进行了 ``detached`` 设置，A 组件切换为 B 组件，对 ``state`` 进行了修改，仍然触发 A 组件的 ``$subscribe``。
+ 可以通过 ``watch`` 监听 ``pinia.state`` 实现对全局 ``state`` 变动监听。