---
layout: post
title: Vue3 的使用
categories: [vue]
tags: [markdown]
---

Vue3 支持组合 API，本篇博文主要介绍 Vue2 到 Vue3 的变化，示例代码来自[vue官网](https://cn.vuejs.org/)。

# Vue3 的使用

+ [全局 API](#全局-api)
    + [defineComponent](#definecomponent)
    + [nextTick](#nexttick)
+ [组合 API](#组合-api)
    + [入口 setup](#入口-setup)




## 全局 API
### defineComponent
入参为配置项，并进行返回，主要用作类型推倒，不再是对象字面量的返回，经过工厂函数后生成带有配置项的实例。

```vue
{% raw %}
<script>
import {
    defineComponent, ref
} from 'vue';
import {
    cmTest
} from './components/cmTest/index.vue';

export default defineComponent({
    name: 'cmTest',
    props: {
        count: {
            type: Number,
            default: 0
        }
    },
    components: {
        cmTest
    },

    // 组合 API 入口
    setup() {
        let count = ref(0);

        return {
            count
        }
    },
    errorCaptured (err, vm, info) {
        console.log('组件错误', err);
    }
});
</script>
{% endraw %}
```

### nextTick
返回值为 promise 对象。

```vue
{% raw %}
<template>
    <button id="counter" @click="increment">{{ count }}</button>
</template>

<script>
import { defineComponent, ref, nextTick } from 'vue';

export default defineComponent({
    setup() {
        let count = ref(0);

        async function increment() {
            count.value++;
            console.log(document.querySelector('#counter').textContent);
            await nextTick();
            console.log(document.querySelector('#counter').textContent);
        }

        return {
            count,
            increment
        };
    }
});
</script>
{% endraw %}
```




## 组合 API
### 入口 setup
数据和方法需要在 return 语句中进行返回。

```vue
{% raw %}
<!-- cmTest 的父组件 -->
<template>
    <div class="gd-body">
        <span @click="changeCountHandle('increase')">自增+</span>
        <span @click="changeCountHandle('reduce')">自减-</span>
        <cm-test ref="cmTest" :count="count" :otherCount="otherCount"/>
    </div>
</template>

<script>
import { defineComponent, ref, onMounted } from 'vue';
import cmTest from './components/cmTest';

export default defineComponent({
    components: {
        cmTest
    },
    setup() {
        let count = ref(0);
        let changeCountHandle = type => {
            if (type === 'increase') {
                count.value++;
            } else if (type === 'reduce') {
                count.value--;
            }
        };

        let otherCount = ref(100);

        // 更新传递给 cmTest 组件的 otherCount 属性，未被 props 接受，组件通过监听 content.attrs.otherCount
        setTimeout(() => {
            otherCount.value = 200;
        }, 1000);

        // 变量名需要和组件的 ref 名相同，调用组件 expose 方法暴露的数据和方法，需要 return 才能使用
        let cmTest = ref(null);
        onMounted(() => {
            setTimeout(() => {
                cmTest.value.updateTitleHandle('更新标题');
            }, 1000);
        });

        return {
            count,
            changeCountHandle,
            otherCount,
            cmTest // 需要返回才能在 mounted 中使用
        };
    }
});
</script>

<!-- cmTest 组件 -->
<template>
    <div class="cm-test">
        <div>{{ title }}</div>
        <div>{{ count }}</div>
    </div>
</template>

<script>
    import { defineComponent, ref, watch, h } from 'vue';

    export default defineComponent({
        name: 'cmTest',
        props: {
            count: {
                type: Number,
                default: 0
            }
        },
        setup(props, context) {
            // props 的数据，等价于 this.count
            console.log('props.count', props.count);

            // 透传 attributes
            console.log('context.$attrs', context.attrs);

            // 监听 attributes
            watch(() => context.attrs.otherCount, (n, o) => {
                console.log('n', n, '-o', o);
            });

            // 插槽（等价于 this.$slots）
            console.log('context.$slots', context.slots);

            // 触发事件（等价于 this.$emit）
            console.log('context.$slots', context.emit);

            // 暴露公共数据的函数
            console.log('context.expose', context.expose);

            let title = ref('标题');
            let updateTitleHandle = val => title.value = val;

            // 父组件通过模板引用组件实例的时候只能访问 expose 函数暴露的内容（不像组合 api 所有的数据方法都挂在实例上都能通过.操作符访问）
            context.expose({
                updateTitleHandle
            });

            return {
                title
            };

            // 使用渲染函数 render 省去 <template> 模板，优先级高于 <template> 和 vue2 的优先级一样
            // return () => h('div', props.count)
        }
    });
</script>
{% endraw %}
```

> + ``props`` 入参如果进行解构，会失去响应式，保持 ``props.xxx`` 使用形式。
+ 父组件需要通过模板引用设置 ``ref`` 访问子组件通过 ``context.expose`` 方法暴露的数据时，``ref`` 需要进行返回才能使用，通过 ``.value`` 数据引用组件。
+ ``setup`` 也可以通过 ``return`` 一个函数返回模板。

